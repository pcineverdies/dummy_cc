use crate::ast::ast_node::{AstNode, AstNodeWrapper, SourceReference};
use crate::ast::type_wrapper::{TypeNative, TypeWrapper};
use crate::lexer::token::{Bracket, Keyword, Operator, Tk, Token};
use crate::parser::symbol_table::{Declaration, SymbolTable};
use std::string::String;
use std::{fs::read_to_string, process::exit};

// Parser
//
// Object to store the information about the parser, currently related to one file only
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Parser {
    token_list: Vec<Token>,    // List of tokens from the lexer
    current_position: usize,   // Current position in the above list
    errors_counter: u32,       // How many errors have been found while parsing (fail if >0)
    file_name: String,         // Name of file under analysis (to print error messages)
    symbol_table: SymbolTable, // Global symbol table
    skip_erorrs: bool,         // In certain situations, it is worth to skip the erorr messages
                               // (when performing backtracking)
}

// ParserResult
//
// Each parsing function can result in a Match (in this case, the function returns the AstNode as
// it was found), Fail or Unmatch (a certain function was called to parse the tokens, but it was
// not the correct one)
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserResult {
    Match(AstNodeWrapper),
    Unmatch,
    Fail,
}

// ParserError
//
// Different kinds of errors can be generated during parsing. Each error contains enough
// information to process the error message
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserError {
    ScopeError(String, String, AstNodeWrapper), // Identifier not found in scope
    RedefintionError(String),                   // Identifier already defined
    TokenError(String),                         // Token is wrong
    NodeError(AstNodeWrapper, String),          // AST node is wrong
}

use AstNode::*;
use Bracket::*;
use Keyword::*;
use Operator::*;
use ParserError::*;
use ParserResult::*;
use Tk::*;

impl Parser {
    //! Parser::new
    //!
    //! Initiate the parser with a vector of tokens generated by the lexer
    //!
    //! @input token_list [Vec<Token>]: List of input tokens
    //! @input file_name [String]: Name of the file under analysis
    //! @return [Parser]: Generated parser
    pub fn new(token_list: Vec<Token>, file_name: String) -> Parser {
        Parser {
            token_list,
            current_position: 0,
            errors_counter: 0,
            file_name,
            symbol_table: SymbolTable::new(),
            skip_erorrs: false,
        }
    }

    /// Parser::get_current
    ///
    /// Get the current token under exam
    ///
    /// @return [Tk]: current Tk
    fn get_current(&self) -> Tk {
        return self.token_list[self.current_position].clone().tk;
    }

    /// Parser::get_current_token
    ///
    /// Get the wrapped current token under exam (with aux information)
    /// Possibly advance
    ///
    /// @in advance[bool]: advance when true
    /// @return [Token]: current token
    fn get_current_token(&mut self, advance: bool) -> Token {
        let res = self.token_list[self.current_position].clone();
        if advance {
            self.advance();
        }
        res
    }

    /// Parser::previous
    ///
    /// Go to previous token
    fn previous(&mut self) {
        self.current_position -= 1;
    }

    /// Parser::advance
    ///
    /// Advance to next token
    fn advance(&mut self) {
        self.current_position += 1;
        if self.current_position as usize >= self.token_list.len() {
            eprintln!("\x1b[91mFailed parsing with {} errors\x1b[0m", self.errors_counter);
            exit(1);
        }
    }

    /// Parser::parse
    ///
    /// Parse the list of token provided to the parser during initialization
    ///
    /// @return [Option<AstNode>]: return the AST in case of success, None if an error occurred in the
    /// process
    pub fn parse(&mut self) -> Option<AstNodeWrapper> {
        // Match a list of declarations
        match self.external_declaration_list() {
            Match(node) => {
                // Next token must be EOF in order for the parsing to be correct. Otherwise spurious
                // spurious tokens are present.
                if self.get_current() != Tk::EOF {
                    self.parser_error(TokenError(format!("EOF")));
                // Else, parsing is considered to be successfull if no errors where found in the process
                } else if self.errors_counter == 0 {
                    return Some(node);
                }
            }
            _ => {}
        }

        eprintln!("\x1b[91mFailed parsing with {} errors\x1b[0m", self.errors_counter);
        return None;
    }

    /// Parser::external_declaration_list
    ///
    /// Parse an external_declaration_list, defined as
    ///
    /// External_declaration_list -> {Declaration}*
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn external_declaration_list(&mut self) -> ParserResult {
        let mut result: Vec<AstNodeWrapper> = Vec::new();
        let mut source_ref = SourceReference { ..Default::default() };
        // While there is no EOF, match every found declaration and add it at the end of the list
        // of declarations
        while self.get_current() != Tk::EOF {
            if let Match(node) = self.declaration() {
                source_ref = SourceReference::merge(&node.source_ref, &source_ref);
                result.push(node)
            } else {
                return Fail;
            }
        }
        return Match(AstNodeWrapper {
            node: AstNode::new_declaration_list(&result),
            source_ref,
            ..Default::default()
        });
    }

    /// Parser::declaration
    ///
    /// Parse a compound_statement, defined as
    ///
    /// Declaration ->  Pointer_type identifier stop
    ///              |  Pointer_type identifier =  Expression stop
    ///              |  Pointer_type identifier ( Parameter_list ) Compound_statement
    ///              |  Pointer_type identifier [ Expression ] stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn declaration(&mut self) -> ParserResult {
        // Each declaration starts with a type
        match self.pointer_type() {
            // After the type we expect an identifier
            Match(type_node) => {
                match self.get_current() {
                    Tk::Identifier(id) => {
                        let id_token = self.get_current_token(true);
                        // If a semicolon is immediately following, a variable is declared without
                        // initialization
                        match self.get_current() {
                            Tk::Semicolon => {
                                // get current token and compute source reference
                                let token = self.get_current_token(true);
                                let source_ref = SourceReference::merge(&type_node.source_ref, &SourceReference::from_token(&token));
                                // The variable is to be added to the symbol table, by checking that
                                // the symbol was not already defined
                                if let AstNode::TypeNode(t) = &type_node.node {
                                    let res = self.symbol_table.add_definition(&Declaration {
                                        name: id.clone(),
                                        return_type: t.clone(),
                                        ..Default::default()
                                    });
                                    if res.is_none() {
                                        return self.parser_error(RedefintionError(id));
                                    }
                                }
                                return Match(AstNodeWrapper {
                                    node: AstNode::new_var_decl(&type_node, &id_token, &AstNodeWrapper { ..Default::default() }),
                                    source_ref,
                                    ..Default::default()
                                });
                            }
                            Tk::Operator(Assign) => {
                                self.advance();
                                // Match following expression
                                match self.expression() {
                                    Match(expr) => {
                                        // Semicolon must follow
                                        if self.get_current() != Tk::Semicolon {
                                            return self.parser_error(TokenError(";".to_string()));
                                        }
                                        let token = self.get_current_token(true);
                                        let source_ref = SourceReference::merge(&type_node.source_ref, &SourceReference::from_token(&token));
                                        let result = AstNodeWrapper {
                                            node: AstNode::new_var_decl(&type_node, &id_token, &expr),
                                            source_ref,
                                            ..Default::default()
                                        };
                                        // Type of the declaration and type of the expression must
                                        // be compatible in order for the assignment to be valid
                                        if !TypeWrapper::are_compatible(&expr.type_ref, &type_node.type_ref) {
                                            return self.parser_error(NodeError(
                                                result,
                                                String::from(format!(
                                                    "mismatched type at assignment: expected {}, found {}",
                                                    type_node.type_ref.to_string(),
                                                    expr.type_ref.to_string()
                                                )),
                                            ));
                                        }
                                        // Add definiton to the symbol table and handle redefintion
                                        if let AstNode::TypeNode(t) = &type_node.node {
                                            let res = self.symbol_table.add_definition(&Declaration {
                                                name: id.clone(),
                                                return_type: t.clone(),
                                                ..Default::default()
                                            });
                                            if res.is_none() {
                                                return self.parser_error(RedefintionError(id));
                                            }
                                        }
                                        return Match(result);
                                    }
                                    _ => return Fail,
                                }
                            }
                            Tk::Bracket(LBracket) => {
                                let mut params_g: Vec<AstNodeWrapper> = vec![];
                                self.advance();
                                // As a left bracket was found, a parameter list is expected
                                match self.parameter_list() {
                                    Match(list) => {
                                        let (body, source_ref);
                                        // after a parameter list, a right bracket is expected
                                        if self.get_current() != Tk::Bracket(RBracket) {
                                            return self.parser_error(TokenError(")".to_string()));
                                        }
                                        self.advance();
                                        // The parameter list returns a function declaration node
                                        // containing the parameters
                                        if let AstNode::FuncDeclNode(_, _, ref params, _) = list.node {
                                            if id == "main" && params.len() != 0 {
                                                return self.parser_error(NodeError(list, format!("Function main cannot have parameters")));
                                            }
                                            let mut parameters_st = Vec::new();
                                            // For each parameter, get type and name and add it to
                                            // the next scope of declaration (inside the scope of
                                            // the function)
                                            for elem in params {
                                                if let AstNode::ParameterNode(name, t_n) = &elem.node {
                                                    if let AstNode::TypeNode(t) = &t_n.node {
                                                        parameters_st.push(t.clone());
                                                        if let Tk::Identifier(n) = &name.tk {
                                                            let res = self.symbol_table.add_to_next_scope(&Declaration {
                                                                name: n.to_string(),
                                                                return_type: t.clone(),
                                                                ..Default::default()
                                                            });
                                                            // redefintion
                                                            if res.is_none() {
                                                                return self.parser_error(RedefintionError(n.to_string()));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // Add definition to the symbol table. As this is done
                                            // before handling the body of the function, recursion
                                            // is possible
                                            params_g = params.clone();
                                            if let AstNode::TypeNode(t) = &type_node.node {
                                                let res = self.symbol_table.add_definition(&Declaration {
                                                    name: id.clone(),
                                                    return_type: t.clone(),
                                                    is_function: true,
                                                    arguments: parameters_st,
                                                    ..Default::default()
                                                });
                                                if res.is_none() {
                                                    return self.parser_error(RedefintionError(id));
                                                }
                                            }
                                        }
                                        match self.compound_statement(false, &type_node.type_ref) {
                                            Match(node) => {
                                                // A return statement must be found having the
                                                // correct expression type
                                                if let AstNode::CompoundNode(list) = &node.node {
                                                    // List of statements is empty
                                                    if list.len() == 0 {
                                                        return self.parser_error(NodeError(
                                                            node.clone(),
                                                            String::from(format!("Missing return statement",)),
                                                        ));
                                                    }
                                                    let mut found_ret = false;
                                                    // Last statement
                                                    if let JumpNode(ref tk, _) = list[&list.len() - 1].clone().node {
                                                        if let Tk::Keyword(Return) = tk.tk {
                                                            found_ret = true;
                                                        }
                                                    }
                                                    // The return statement was not found
                                                    if !found_ret {
                                                        return self.parser_error(NodeError(
                                                            list[&list.len() - 1].clone(),
                                                            String::from(format!(
                                                                "Last statement must be return with type {}",
                                                                type_node.type_ref.to_string()
                                                            )),
                                                        ));
                                                    }
                                                }
                                                body = node;
                                                source_ref = SourceReference::merge(&type_node.source_ref, &body.source_ref);
                                            }
                                            _ => return Fail,
                                        }
                                        return Match(AstNodeWrapper {
                                            node: AstNode::new_func_decl(&type_node, &id_token, &params_g, &body),
                                            source_ref,
                                            ..Default::default()
                                        });
                                    }
                                    _ => return Fail,
                                }
                            }
                            // Definition of array
                            Tk::Bracket(LSquare) => {
                                self.advance();
                                // Expression to get the size of the array
                                match self.expression() {
                                    Match(node) => {
                                        if self.get_current() != Tk::Bracket(RSquare) {
                                            return self.parser_error(TokenError("]".to_string()));
                                        }
                                        self.advance();
                                        if self.get_current() != Tk::Semicolon {
                                            return self.parser_error(TokenError(";".to_string()));
                                        }
                                        if node.type_ref.pointer != 0 || node.type_ref.type_native != TypeNative::U32 {
                                            return self.parser_error(NodeError(
                                                node.clone(),
                                                String::from(format!(
                                                    "Cannot use type {} for array declaration (u32 only)",
                                                    node.type_ref.to_string()
                                                )),
                                            ));
                                        }
                                        let token = self.get_current_token(true);
                                        let source_ref = SourceReference::merge(&type_node.source_ref, &SourceReference::from_token(&token));
                                        if let AstNode::TypeNode(mut t) = type_node.node.clone() {
                                            t.pointer += 1;
                                            self.symbol_table.add_definition(&Declaration {
                                                name: id,
                                                return_type: t.clone(),
                                                ..Default::default()
                                            });
                                        }
                                        return Match(AstNodeWrapper {
                                            node: AstNode::new_array_decl(&type_node, &id_token, &node),
                                            source_ref,
                                            ..Default::default()
                                        });
                                    }
                                    _ => return Fail,
                                }
                            }
                            _ => return self.parser_error(TokenError(String::from(""))),
                        };
                    }
                    _ => {
                        return self.parser_error(TokenError("identifier".to_string()));
                    }
                }
            }
            _ => return Fail,
        }
    }

    /// Parser::parameter_list
    ///
    /// Parse a parameter_list, defined as
    ///
    /// Parameter_list ->   {Pointer_type identifier {, Pointer_type identifier}* }
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn parameter_list(&mut self) -> ParserResult {
        // List of parameters
        let mut result: Vec<AstNodeWrapper> = Vec::new();
        let mut source_ref_g: SourceReference = Default::default();

        // Handle case of empty list: loop over types only if current is not right bracket
        if self.get_current() != Tk::Bracket(RBracket) {
            source_ref_g = SourceReference::from_token(&self.get_current_token(false));
            loop {
                match self.pointer_type() {
                    Match(type_node) => match self.get_current() {
                        Identifier(_) => {
                            let token = self.get_current_token(true);
                            let source_ref = SourceReference::merge(&SourceReference::from_token(&token), &type_node.source_ref);
                            result.push(AstNodeWrapper {
                                node: AstNode::new_parameter(&token, &type_node),
                                source_ref,
                                type_ref: type_node.type_ref.clone(),
                                ..Default::default()
                            });
                            // Iterate again if next is comma
                            if self.get_current() == Tk::Operator(Operator::Comma) {
                                self.advance();
                            // Error if next is not right bracket
                            } else if self.get_current() != Tk::Bracket(Bracket::RBracket) {
                                return self.parser_error(TokenError(")".to_string()));
                            // If right bracket, stop loop
                            } else {
                                source_ref_g = SourceReference::merge(&source_ref_g, &SourceReference::from_token(&self.get_current_token(false)));
                                break;
                            }
                        }
                        _ => return self.parser_error(TokenError("identifier".to_string())),
                    },
                    _ => return Fail,
                }
            }
        }
        return Match(AstNodeWrapper {
            node: AstNode::new_func_decl(
                &AstNodeWrapper { ..Default::default() },
                &self.get_current_token(false),
                &result,
                &AstNodeWrapper { ..Default::default() },
            ),
            source_ref: source_ref_g,
            ..Default::default()
        });
    }

    /// Parser::compound_statement
    ///
    /// Parse a compound_statement, defined as
    ///
    /// Compound_statement ->  { {statement}* }
    ///
    /// @in in_loop [bool]: whether the statement is currently in a loop or not
    /// @in return_type [TypeWrapper]: expected return type
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn compound_statement(&mut self, in_loop: bool, return_type: &TypeWrapper) -> ParserResult {
        let mut result: Vec<AstNodeWrapper> = Vec::new();
        if self.get_current() != Tk::Bracket(LCurly) {
            return self.parser_error(TokenError("{".to_string()));
        }
        let token_l = self.get_current_token(true);
        let mut found_jump = false;
        // When entering a compound statement, a new scope is added
        self.symbol_table.add_scope();
        while self.get_current() != Tk::Bracket(RCurly) {
            // Match a statement as long as possible
            match self.statement(in_loop, &return_type) {
                Match(node) => {
                    if found_jump {
                        self.parser_warning(NodeError(node.clone(), "Statement cannot be reached".to_string()));
                    }
                    // Add to the list of node if different from null (empty semicolon)
                    if node.node != AstNode::NullNode && !found_jump {
                        result.push(node.clone());
                        // If the statement is of type JumpNode, the code which follow in the same
                        // compound statement cannot be reached
                        if let JumpNode(..) = node.node {
                            found_jump = true;
                        }
                    }
                }
                // In case of error, we skip the tokens until a new semicolon or a curly bracket
                _ => {
                    while self.get_current() != Tk::Bracket(RCurly) && self.get_current() != Tk::Semicolon {
                        self.advance();
                    }
                    if self.get_current() == Tk::Semicolon {
                        self.advance();
                    }
                }
            }
        }
        // Remove scope
        self.symbol_table.remove_scope();
        // Expect closed curly bracket to terminate scope
        if self.get_current() != Tk::Bracket(RCurly) {
            return self.parser_error(TokenError("}".to_string()));
        }
        // create source referecne
        let token_r = self.get_current_token(true);
        let source_ref = SourceReference::merge(&SourceReference::from_token(&token_l), &SourceReference::from_token(&token_r));
        // return compound statement
        return Match(AstNodeWrapper {
            node: AstNode::new_compound(&result),
            source_ref,
            ..Default::default()
        });
    }

    /// Parser::statement
    ///
    /// Parse a statement, defined as
    ///
    /// Statement ->    Expression_statement
    ///            |    Declaration
    ///            |    Compound_statement
    ///            |    Selection_statement
    ///            |    Iteration_statement
    ///            |    Jump_statement
    ///
    /// @in in_loop [bool]: whether the statement is currently in a loop or not
    /// @in return_type [TypeWrapper]: expected return type
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn statement(&mut self, in_loop: bool, return_type: &TypeWrapper) -> ParserResult {
        // A declaration starts with a type or with a the `const` keyword
        if self.get_current().is_type() || self.get_current() == Tk::Keyword(Const) {
            match self.declaration() {
                Match(node) => return Match(node),
                Fail => return Fail,
                Unmatch => {}
            }
        }

        match self.get_current() {
            // If left curly, then we have a compound statement
            Tk::Bracket(LCurly) => match self.compound_statement(in_loop, &return_type) {
                Match(node) => return Match(node),
                _ => return Fail,
            },
            // If `if` token, then we have an if statement
            Tk::Keyword(Keyword::If) => match self.selection_statement(in_loop, &return_type) {
                Match(node) => return Match(node),
                _ => return Fail,
            },
            // If `break` or `continue` token, then we have jump statement
            Tk::Keyword(Break) | Tk::Keyword(Continue) => match self.jump_statement(&return_type) {
                Match(node) => {
                    // Such jump is allowed only in loop
                    if !in_loop {
                        return self.parser_error(NodeError(
                            node.clone(),
                            String::from(format!("Cannot use break or continue outside of loop",)),
                        ));
                    }
                    return Match(node);
                }
                _ => return Fail,
            },
            // If `return` token, then we have a jump statement
            Tk::Keyword(Return) => match self.jump_statement(&return_type) {
                Match(node) => {
                    return Match(node);
                }
                _ => return Fail,
            },
            // If `while` or `for` token, then we have a loop
            Tk::Keyword(While) | Tk::Keyword(For) => match self.iteration_statement(&return_type) {
                Match(node) => return Match(node),
                _ => return Fail,
            },
            _ => {}
        }

        // In all the other cases, we have an expression statement. If this returns fail, then
        // there are no alternatives and the statement parsing returns fail
        match self.expression_statement() {
            Match(node) => return Match(node),
            _ => return Fail,
        }
    }

    /// Parser::jump_statement
    /// Parse an jump_statement, defined as
    ///
    /// Jump_statement ->   return Optional_expression stop
    ///                 |   break stop
    ///                 |   continue stop
    ///
    /// @in return_type [TypeWrapper]: expected return type
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn jump_statement(&mut self, return_type: &TypeWrapper) -> ParserResult {
        let token = self.get_current_token(false);
        let mut result_expr = AstNodeWrapper { ..Default::default() };
        let source_ref: SourceReference;
        match self.get_current() {
            Tk::Keyword(Continue) | Tk::Keyword(Break) => {
                self.advance();
            }
            Tk::Keyword(Return) => {
                self.advance();
                match self.optional_expression() {
                    Match(expr) => {
                        // The type of the return expression must match the type of the return type
                        // of the function. A non void function must have a return type
                        if return_type.type_native == TypeNative::Void && expr.node != AstNode::NullNode {
                            return self.parser_error(NodeError(
                                expr.clone(),
                                String::from(format!("Function has type void but {} was found", expr.type_ref.to_string())),
                            ));
                        }
                        result_expr = expr;
                    }
                    _ => return Fail,
                }
            }
            _ => return self.parser_error(TokenError("".to_string())),
        }
        if self.get_current() != Tk::Semicolon {
            return self.parser_error(TokenError(";".to_string()));
        }
        let semicolon = self.get_current_token(true);
        source_ref = SourceReference::merge(&SourceReference::from_token(&token), &SourceReference::from_token(&semicolon));
        let result = AstNodeWrapper {
            node: AstNode::new_jump(&token, &result_expr),
            source_ref,
            ..Default::default()
        };
        // Type is not void and mismatch between types was found
        if return_type.type_native != TypeNative::Void && result_expr.type_ref != *return_type {
            return self.parser_error(NodeError(
                result,
                String::from(format!(
                    "Function has type {} but {} was found",
                    return_type.to_string(),
                    result_expr.type_ref.to_string()
                )),
            ));
        }
        return Match(result);
    }

    /// Parser::iteration_statement
    /// Parse an iteration statement, defined as
    ///
    /// Iteration_statement ->  while ( Expression ) Compound_statement
    ///                      |  for ( Optional_expression stop Optional_expression stop Optional_expression ) Compound_statement
    ///
    /// @in return_type [TypeWrapper]: expected return type
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn iteration_statement(&mut self, return_type: &TypeWrapper) -> ParserResult {
        match self.get_current() {
            Tk::Keyword(For) => {
                let token = self.get_current_token(true);
                if self.get_current() != Tk::Bracket(LBracket) {
                    return self.parser_error(TokenError("(".to_string()));
                }
                self.advance();
                // Match first expression
                if let Match(expr1) = self.optional_expression() {
                    if self.get_current() != Tk::Semicolon {
                        return self.parser_error(TokenError(";".to_string()));
                    }
                    self.advance();
                    // Match second expression
                    if let Match(expr2) = self.optional_expression() {
                        if self.get_current() != Tk::Semicolon {
                            return self.parser_error(TokenError(";".to_string()));
                        }
                        self.advance();
                        // Match third expression
                        if let Match(expr3) = self.optional_expression() {
                            if self.get_current() != Tk::Bracket(RBracket) {
                                return self.parser_error(TokenError(")".to_string()));
                            }
                            self.advance();
                            // Match body of the for loop
                            if let Match(body) = self.compound_statement(true, &return_type) {
                                let source_ref = SourceReference::merge(&SourceReference::from_token(&token), &body.source_ref);
                                let result = AstNodeWrapper {
                                    node: AstNode::new_for(&expr1, &expr2, &expr3, &body),
                                    source_ref,
                                    ..Default::default()
                                };
                                return Match(result);
                            }
                        }
                    }
                }
                return Fail;
            }
            Tk::Keyword(While) => {
                let token = self.get_current_token(true);
                if let Tk::Bracket(LBracket) = self.get_current() {
                    self.advance();
                    // Match expression of while
                    if let Match(expr) = self.expression() {
                        if let Tk::Bracket(RBracket) = self.get_current() {
                            self.advance();
                            // Match body
                            if let Match(body) = self.compound_statement(true, return_type) {
                                let source_ref = SourceReference::merge(&SourceReference::from_token(&token), &body.source_ref);
                                return Match(AstNodeWrapper {
                                    node: AstNode::new_while(&expr, &body),
                                    source_ref,
                                    ..Default::default()
                                });
                            } else {
                                return Fail;
                            }
                        } else {
                            return self.parser_error(TokenError(")".to_string()));
                        }
                    } else {
                        return Fail;
                    }
                } else {
                    return self.parser_error(TokenError("(".to_string()));
                }
            }
            _ => {
                return self.parser_error(TokenError("".to_string()));
            }
        }
    }

    /// Parser::selection_statement
    ///
    /// Parse a selection_statement, defined as
    ///
    /// Selection_statement ->  if ( Expression ) Compound_statement Else_statement
    ///
    /// @in in_loop [bool]: whether the statement is currently in a loop or not
    /// @in return_type [TypeWrapper]: expected return type
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn selection_statement(&mut self, in_loop: bool, return_type: &TypeWrapper) -> ParserResult {
        // Must match if token
        if let Tk::Keyword(If) = self.get_current() {
            let token = self.get_current_token(true);
            if self.get_current() != Tk::Bracket(LBracket) {
                self.parser_error(TokenError("(".to_string()));
            }
            self.advance();
            // Match expression in the if condition
            if let Match(expr) = self.expression() {
                if self.get_current() != Tk::Bracket(RBracket) {
                    self.parser_error(TokenError(")".to_string()));
                }
                self.advance();
                // Match body of the if statement
                match self.compound_statement(in_loop, &return_type) {
                    Match(body) => match self.else_statement(in_loop, &return_type) {
                        // Match else statement
                        Match(else_body) => {
                            let source_ref = SourceReference::merge(&SourceReference::from_token(&token), &body.source_ref);
                            return Match(AstNodeWrapper {
                                node: AstNode::new_if(&expr, &body, &else_body),
                                source_ref,
                                ..Default::default()
                            });
                        }
                        _ => return Fail,
                    },
                    _ => return Fail,
                }
            } else {
                return Fail;
            }
        } else {
            return self.parser_error(TokenError("if".to_string()));
        }
    }

    /// Parser::else_statement
    ///
    /// Parse an else_statement, defined as
    ///
    /// Else_statement ->   ε
    ///                 |   else Compound_statement
    ///
    /// @in in_loop [bool]: whether the statement is currently in a loop or not
    /// @in return_type [TypeWrapper]: expected return type
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn else_statement(&mut self, in_loop: bool, return_type: &TypeWrapper) -> ParserResult {
        // If else is not present, return an empty node
        if self.get_current() != Tk::Keyword(Else) {
            return Match(AstNodeWrapper { ..Default::default() });
        }
        // Otherwise, parse the following compound statement
        let token = self.get_current_token(true);
        match self.compound_statement(in_loop, &return_type) {
            Match(mut node) => {
                node.source_ref = SourceReference::merge(&SourceReference::from_token(&token), &node.source_ref);
                Match(node)
            }
            _ => Fail,
        }
    }

    /// Parser::expression_statement
    ///
    /// Parse an expression_statement, defined as
    ///
    /// Expression_statement -> Optional_expression stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_statement(&mut self) -> ParserResult {
        // Match optional expression (possibly empty)
        match self.optional_expression() {
            Match(node) => {
                if self.get_current() != Tk::Semicolon {
                    return self.parser_error(TokenError(";".to_string()));
                }
                let token = self.get_current_token(true);
                if node.node == AstNode::NullNode {
                    return Match(node);
                }
                let source_ref = SourceReference::merge(&SourceReference::from_token(&token), &node.source_ref);
                return Match(AstNodeWrapper {
                    node: AstNode::new_expr_statement(&node),
                    source_ref,
                    ..Default::default()
                });
            }
            _ => return Fail,
        }
    }

    /// Parser::optional_expression
    ///
    /// Optional_expression ->  Expression
    ///                      |  ε
    ///
    /// Expression_statement -> Optional_expression stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn optional_expression(&mut self) -> ParserResult {
        // Allowed tokens to follow an empty expression
        match self.get_current() {
            Tk::Semicolon | Tk::Bracket(RBracket) => {
                return Match(AstNodeWrapper { ..Default::default() });
            }
            _ => {}
        }

        return self.expression();
    }

    /// Parser::expression
    ///
    /// Parse an expression, defined as
    ///
    /// Expression ->    Logical_expression
    ///             |    Unary_expression = Expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression(&mut self) -> ParserResult {
        // While parsing expression, try to parse and unary expression followed by an assigment. If
        // there are errors, then we have to backtrack to try with a logical expression. From that
        // point on, errors are allowed
        let state_parser = self.clone();
        self.skip_erorrs = true;

        match self.unary_expression() {
            Match(node_unary) => {
                self.skip_erorrs = false;
                match self.get_current() {
                    Operator(Assign) => {
                        // On the left side of an assignment only an lvalue is allowed
                        if !node_unary.is_lvalue {
                            return self.parser_error(NodeError(
                                node_unary.clone(),
                                String::from(format!("cannot assign as it is not an lvalue",)),
                            ));
                        }
                        // Cannot assign to constant
                        if node_unary.type_ref.constant {
                            return self.parser_error(NodeError(
                                node_unary.clone(),
                                String::from(format!("cannot assign as variable is declared as const",)),
                            ));
                        }
                        let token = self.get_current_token(true);
                        match self.expression() {
                            Match(node) => {
                                let source_ref = SourceReference::merge(&node_unary.source_ref, &node.source_ref);
                                let result = AstNodeWrapper {
                                    node: AstNode::new_binary(&token, &node_unary, &node),
                                    source_ref,
                                    // An assigment is an lvalue
                                    is_lvalue: true,
                                    type_ref: node_unary.type_ref.clone(),
                                    ..Default::default()
                                };
                                // Type of the lvalue and type of the right expression must be
                                // compatible
                                if !TypeWrapper::are_compatible(&node.type_ref, &node_unary.type_ref) {
                                    return self.parser_error(NodeError(
                                        result,
                                        String::from(format!(
                                            "mismatched type at assignment: expected {}, found {}",
                                            node_unary.type_ref.to_string(),
                                            node.type_ref.to_string()
                                        )),
                                    ));
                                }
                                return Match(result);
                            }
                            _ => return Fail,
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        // Backtack and match logical expression (skip errors is now false)
        *self = state_parser;
        return self.logical_expression();
    }

    /// Parser::logical_expression
    ///
    /// Parse a logical_expression, defined as
    ///
    /// Logical_expression ->   Equality_expression
    ///                     |   Equality_expression & Logical_expression
    ///                     |   Equality_expression | Logical_expression
    ///                     |   Equality_expression ^ Logical_expression
    ///                     |   Equality_expression and Logical_expression
    ///                     |   Equality_expression or Logical_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn logical_expression(&mut self) -> ParserResult {
        // stack for nodes (to have right associativity)
        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        // Match following expression
        match self.equality_expression() {
            Match(first) => {
                node_stack.push(first.clone());
                // Continue parsing expression until one of these tokens is found
                while self.get_current() == Tk::Operator(AndOp)
                    || self.get_current() == Tk::Operator(OrOp)
                    || self.get_current() == Tk::Operator(XorOp)
                    || self.get_current() == Tk::Keyword(And)
                    || self.get_current() == Tk::Keyword(Or)
                {
                    op_stack.push(self.get_current_token(true));
                    match self.equality_expression() {
                        Match(node) => {
                            // Cannot apply the operation on pointer type
                            if node.type_ref.pointer != 0 {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!("type {} cannot be used in current expression", node.type_ref.to_string(),)),
                                ));
                            }
                            // Types must be compatible
                            if !TypeWrapper::are_compatible(&node.type_ref, &first.type_ref) {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!(
                                        "type {} cannot be used in current expression; expected {}",
                                        node.type_ref.to_string(),
                                        first.type_ref.to_string()
                                    )),
                                ));
                            }
                            node_stack.push(node)
                        }
                        _ => return Fail,
                    }
                }
                // Handle nodes from right to left
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        type_ref: first.type_ref.clone(),
                        ..Default::default()
                    };
                }

                // Only these tokens are valid as next nodes
                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                {
                    return self.parser_error(TokenError("".to_string()));
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::equality_expression
    ///
    /// Parse an equality_expression, defined as
    ///
    /// Equality_expression ->  Relational_expression
    ///                      |  Relational_expression == Equality_expression
    ///                      |  Relational_expression != Equality_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn equality_expression(&mut self) -> ParserResult {
        // stack for nodes (to have right associativity)
        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        // Match following expression
        match self.relational_expression() {
            Match(first) => {
                node_stack.push(first.clone());
                // Continue parsing expression until one of these tokens is found
                while self.get_current() == Tk::Operator(EqualCompare) || self.get_current() == Tk::Operator(DiffCompare) {
                    op_stack.push(self.get_current_token(true));
                    match self.relational_expression() {
                        Match(node) => {
                            // Cannot apply the operation on pointer type
                            if node.type_ref != first.type_ref {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!(
                                        "type {} cannot be used in current expression; expected {}",
                                        node.type_ref.to_string(),
                                        first.type_ref.to_string()
                                    )),
                                ));
                            }
                            // Types must be compatible
                            if !TypeWrapper::are_compatible(&node.type_ref, &first.type_ref) {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!(
                                        "type {} cannot be used in current expression; expected {}",
                                        node.type_ref.to_string(),
                                        first.type_ref.to_string()
                                    )),
                                ));
                            }
                            node_stack.push(node)
                        }
                        _ => return Fail,
                    }
                }
                // Handle nodes from right to left
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        type_ref: first.type_ref.clone(),
                        ..Default::default()
                    };
                }

                // Only these tokens are valid as next nodes
                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                {
                    return self.parser_error(TokenError("".to_string()));
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::relational_expression
    ///
    /// Parse a relational_expression, defined as
    ///
    /// Relational_expression ->    Shift_expression
    ///                        |    Shift_expression >= Relational_expression
    ///                        |    Shift_expression <= Relational_expression
    ///                        |    Shift_expression < Relational_expression
    ///                        |    Shift_expression > Relational_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn relational_expression(&mut self) -> ParserResult {
        // stack for nodes (to have right associativity)
        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        // Match following expression
        match self.shift_expression() {
            Match(first) => {
                node_stack.push(first.clone());
                // Continue parsing expression until one of these tokens is found
                while self.get_current() == Tk::Operator(LECompare)
                    || self.get_current() == Tk::Operator(GECompare)
                    || self.get_current() == Tk::Operator(LTCompare)
                    || self.get_current() == Tk::Operator(GTCompare)
                {
                    op_stack.push(self.get_current_token(true));
                    match self.shift_expression() {
                        Match(node) => {
                            // Cannot apply the operation on pointer type
                            if node.type_ref.pointer != 0 {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!("type {} cannot be used in current expression", node.type_ref.to_string())),
                                ));
                            }
                            // Types must be compatible
                            if !TypeWrapper::are_compatible(&node.type_ref, &first.type_ref) {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!(
                                        "type {} cannot be used in current expression; expected {}",
                                        node.type_ref.to_string(),
                                        first.type_ref.to_string()
                                    )),
                                ));
                            }
                            node_stack.push(node)
                        }
                        _ => return Fail,
                    }
                }
                // Handle nodes from right to left
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        type_ref: first.type_ref.clone(),
                        ..Default::default()
                    };
                }

                // Only these tokens are valid as next nodes
                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                    && self.get_current() != Tk::Operator(EqualCompare)
                    && self.get_current() != Tk::Operator(DiffCompare)
                {
                    return self.parser_error(TokenError("".to_string()));
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::shift_expression
    ///
    /// Parse a shift_expression, defined as
    ///
    /// Shift_expression -> Additive_expression
    ///                   | Additive_expression << Shift_expression
    ///                   | Additive_expression >> Shift_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn shift_expression(&mut self) -> ParserResult {
        // stack for nodes (to have right associativity)
        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        // Match following expression
        match self.additive_expression() {
            Match(first) => {
                node_stack.push(first.clone());
                // Continue parsing expression until one of these tokens is found
                while self.get_current() == Tk::Operator(LShift) || self.get_current() == Tk::Operator(RShift) {
                    op_stack.push(self.get_current_token(true));
                    match self.additive_expression() {
                        Match(node) => {
                            // Cannot apply the operation on pointer type
                            if node.type_ref.pointer != 0 {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!("type {} cannot be used in current expression", node.type_ref.to_string())),
                                ));
                            }
                            // Types must be compatible
                            if !TypeWrapper::are_compatible(&node.type_ref, &first.type_ref) {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!(
                                        "type {} cannot be used in current expression; expected {}",
                                        node.type_ref.to_string(),
                                        first.type_ref.to_string()
                                    )),
                                ));
                            }
                            node_stack.push(node)
                        }
                        _ => return Fail,
                    }
                }
                // Handle nodes from right to left
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        type_ref: first.type_ref.clone(),
                        ..Default::default()
                    };
                }

                // Only these tokens are valid as next nodes
                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                    && self.get_current() != Tk::Operator(EqualCompare)
                    && self.get_current() != Tk::Operator(DiffCompare)
                    && self.get_current() != Tk::Operator(LTCompare)
                    && self.get_current() != Tk::Operator(GTCompare)
                    && self.get_current() != Tk::Operator(LECompare)
                    && self.get_current() != Tk::Operator(GECompare)
                {
                    return self.parser_error(TokenError("".to_string()));
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::additive_expression
    ///
    /// Parse a additive_expression, defined as
    ///
    /// Additive_expression ->  Multiplicative_expression
    ///                      |  Multiplicative_expression + Additive_expression
    ///                      |  Multiplicative_expression - Additive_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn additive_expression(&mut self) -> ParserResult {
        // stack for nodes (to have right associativity)
        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        // Match following expression
        match self.multiplicative_expression() {
            Match(first) => {
                node_stack.push(first.clone());
                // Continue parsing expression until one of these tokens is found
                while self.get_current() == Tk::Operator(Plus) || self.get_current() == Tk::Operator(Minus) {
                    op_stack.push(self.get_current_token(true));
                    match self.multiplicative_expression() {
                        Match(node) => {
                            // Types must be compatible
                            if !TypeWrapper::are_compatible(&node.type_ref, &first.type_ref) {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!(
                                        "type {} cannot be used in current expression; expected {}",
                                        node.type_ref.to_string(),
                                        first.type_ref.to_string()
                                    )),
                                ));
                            }
                            node_stack.push(node)
                        }
                        _ => return Fail,
                    }
                }
                // Handle nodes from right to left
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        type_ref: first.type_ref.clone(),
                        ..Default::default()
                    };
                }

                // Only these tokens are valid as next nodes
                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                    && self.get_current() != Tk::Operator(EqualCompare)
                    && self.get_current() != Tk::Operator(DiffCompare)
                    && self.get_current() != Tk::Operator(LTCompare)
                    && self.get_current() != Tk::Operator(GTCompare)
                    && self.get_current() != Tk::Operator(LECompare)
                    && self.get_current() != Tk::Operator(GECompare)
                    && self.get_current() != Tk::Operator(LShift)
                    && self.get_current() != Tk::Operator(RShift)
                {
                    return self.parser_error(TokenError("".to_string()));
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::multiplicative_expression
    ///
    /// Parse a multiplicative_expression, defined as
    ///
    /// Multiplicative_expression -> Cast_expression
    ///                            | Cast_expression * Multiplicative_expression
    ///                            | Cast_expression / Multiplicative_expression
    ///                            | Cast_expression % Multiplicative_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn multiplicative_expression(&mut self) -> ParserResult {
        // stack for nodes (to have right associativity)
        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        // Match following expression
        match self.cast_expression() {
            Match(first) => {
                node_stack.push(first.clone());
                // Continue parsing expression until one of these tokens is found
                while self.get_current() == Tk::Operator(Asterisk)
                    || self.get_current() == Tk::Operator(Slash)
                    || self.get_current() == Tk::Operator(Module)
                {
                    op_stack.push(self.get_current_token(true));
                    match self.cast_expression() {
                        Match(node) => {
                            // Cannot apply the operation on pointer type
                            if node.type_ref.pointer != 0 {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!("type {} cannot be used in current expression", node.type_ref.to_string())),
                                ));
                            }
                            // Types must be compatible
                            if !TypeWrapper::are_compatible(&node.type_ref, &first.type_ref) {
                                return self.parser_error(NodeError(
                                    node.clone(),
                                    String::from(format!(
                                        "type {} cannot be used in current expression; expected {}",
                                        node.type_ref.to_string(),
                                        first.type_ref.to_string()
                                    )),
                                ));
                            }
                            node_stack.push(node);
                        }
                        _ => return Fail,
                    }
                }
                // Handle nodes from right to left
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        type_ref: first.type_ref.clone(),
                        ..Default::default()
                    };
                }

                // Only these tokens are valid as next nodes
                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                    && self.get_current() != Tk::Operator(EqualCompare)
                    && self.get_current() != Tk::Operator(DiffCompare)
                    && self.get_current() != Tk::Operator(LTCompare)
                    && self.get_current() != Tk::Operator(GTCompare)
                    && self.get_current() != Tk::Operator(LECompare)
                    && self.get_current() != Tk::Operator(GECompare)
                    && self.get_current() != Tk::Operator(LShift)
                    && self.get_current() != Tk::Operator(RShift)
                    && self.get_current() != Tk::Operator(Plus)
                    && self.get_current() != Tk::Operator(Minus)
                {
                    return self.parser_error(TokenError("".to_string()));
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::cast_expression
    ///
    /// Parse a cast_expression, defined as
    ///
    /// Cast_expression ->  ( Pointer_type ) Cast_expression
    ///                  |  Unary_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn cast_expression(&mut self) -> ParserResult {
        match self.get_current() {
            Tk::Bracket(LBracket) => {
                let token_l = self.get_current_token(true);
                // match cast
                if self.get_current().is_type() || self.get_current() == Tk::Keyword(Const) {
                    match self.pointer_type() {
                        Match(type_node) => match self.get_current() {
                            Tk::Bracket(RBracket) => {
                                self.advance();
                                // match new cast expression
                                match self.cast_expression() {
                                    Match(node) => {
                                        let source_ref = SourceReference::merge(&SourceReference::from_token(&token_l), &node.source_ref);
                                        let result = AstNodeWrapper {
                                            node: AstNode::new_cast(&type_node, &node),
                                            source_ref,
                                            type_ref: type_node.type_ref.clone(),
                                            ..Default::default()
                                        };
                                        if node.type_ref.type_native == TypeNative::Null || node.type_ref.type_native == TypeNative::Void {
                                            return self.parser_error(NodeError(
                                                result,
                                                format!("Cannot cast {} into {}", node.type_ref.to_string(), type_node.type_ref.to_string()),
                                            ));
                                        }
                                        return Match(result);
                                    }
                                    _ => return Fail,
                                }
                            }
                            _ => return self.parser_error(TokenError(")".to_string())),
                        },
                        Unmatch => {
                            self.previous();
                        }
                        _ => return Fail,
                    }
                } else {
                    self.previous();
                }
            }
            _ => {}
        }
        match self.unary_expression() {
            Match(node) => Match(node),
            _ => Fail,
        }
    }

    /// Parser::pointer_type
    ///
    /// Parse a pointer_type, defined as
    ///
    /// Pointer_type -> {const} Type_native {*}*
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn pointer_type(&mut self) -> ParserResult {
        let mut pointer_counter = 0;
        let mut is_const = false;
        let mut source_ref = SourceReference::from_token(&self.get_current_token(false));
        // match const keyword (optional)
        if self.get_current() == Tk::Keyword(Const) {
            is_const = true;
            self.advance();
        }
        // Match type
        match self.type_native() {
            Match(node) => {
                source_ref = SourceReference::merge(&source_ref, &node.source_ref);
                // Match pointers as long as there are asterisks
                while self.get_current() == Tk::Operator(Asterisk) {
                    pointer_counter += 1;
                    source_ref = SourceReference::merge(&source_ref, &SourceReference::from_token(&self.get_current_token(true)));
                }
                match self.get_current() {
                    Tk::Identifier(_) | Tk::Bracket(RBracket) => {}
                    _ => return self.parser_error(TokenError("".to_string())),
                }
                // Return type node
                match node.node {
                    AstNode::TypeNode(mut t) => {
                        t.constant = is_const;
                        t.pointer = pointer_counter;
                        let new_node = AstNode::new_type(&t);
                        return Match(AstNodeWrapper {
                            node: new_node,
                            source_ref,
                            type_ref: t,
                            ..Default::default()
                        });
                    }
                    _ => return Fail,
                }
            }
            _ => Fail,
        }
    }

    /// Parser::type_native
    ///
    /// Parse a type_native, defined as
    ///
    /// Type_native -> u8 | u16 | u32 | i8 | i16 | i32 | void
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn type_native(&mut self) -> ParserResult {
        if self.get_current().is_type() {
            let token = self.get_current_token(true);
            let source_ref = SourceReference::from_token(&token);
            let type_native = TypeNative::from_token(&token);
            return Match(AstNodeWrapper {
                node: AstNode::new_type(&TypeWrapper {
                    type_native,
                    constant: false,
                    pointer: 0,
                }),
                source_ref,
                ..Default::default()
            });
        } else {
            return self.parser_error(TokenError("type".to_string()));
        }
    }

    /// Parser::unary_expression
    ///
    /// Parse a unary_expression, defined as
    ///
    /// Unary_expression -> Postfix_expression
    ///                   | + Unary_expression
    ///                   | - Unary_expression
    ///                   | ! Unary_expression
    ///                   | & Unary_expression
    ///                   | * Unary_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn unary_expression(&mut self) -> ParserResult {
        match self.get_current() {
            Tk::Operator(Plus)
            | Tk::Operator(Minus)
            | Tk::Operator(Complement)
            | Tk::Operator(AndOp)
            | Tk::Operator(Asterisk)
            | Tk::Operator(Not) => {
                let token = self.get_current_token(true);
                match self.unary_expression() {
                    Match(node) => {
                        let source_ref = SourceReference::merge(&SourceReference::from_token(&token), &node.source_ref);
                        let mut result = AstNodeWrapper {
                            node: AstNode::new_prefix(&token, &node),
                            source_ref,
                            ..Default::default()
                        };
                        let mut type_ref = node.type_ref.clone();
                        // Dereferencing can be done only on pointers
                        if let Tk::Operator(Asterisk) = token.tk {
                            if type_ref.pointer == 0 {
                                return self.parser_error(NodeError(result, String::from("Cannot dereference non-pointer type")));
                            }
                            type_ref.pointer -= 1;
                            result.is_lvalue = true;
                        // Address can be extracted only from lvalues
                        } else if let Tk::Operator(AndOp) = token.tk {
                            if !node.is_lvalue {
                                return self.parser_error(NodeError(result, String::from("Cannot extract address from rvalue")));
                            }
                            type_ref.pointer += 1;
                            result.is_lvalue = false;
                        // Other unary operators can be applied only on non-pointer types
                        } else {
                            if type_ref.pointer == 1 {
                                return self.parser_error(NodeError(result, String::from("Cannot apply unary operator on pointer type")));
                            }
                            result.is_lvalue = false;
                            // When using the minus operator, convert the node to I32 type
                            if let Tk::Operator(Minus) = token.tk {
                                type_ref.type_native = TypeNative::I32;
                            }
                        };
                        result.type_ref = type_ref;
                        return Match(result);
                    }
                    _ => return Fail,
                }
            }
            _ => match self.postfix_expression() {
                Match(node) => Match(node),
                _ => Fail,
            },
        }
    }

    /// Parser::postfix_expression
    ///
    /// Parse a postfix_expression, defined as
    ///
    /// Postfix_expression ->   Primary_expression  Postfix_operator
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn postfix_expression(&mut self) -> ParserResult {
        match self.primary_expression() {
            Match(mut node) => {
                // Postfix operators are left associative
                while self.get_current() == Tk::Bracket(LSquare) || self.get_current() == Tk::Bracket(LBracket) {
                    match self.postfix_operator() {
                        Match(node_operator) => {
                            let source_ref = SourceReference::merge(&node.source_ref, &node_operator.source_ref);
                            match node_operator.node {
                                SelectorNode(_, op) => {
                                    let mut type_ref = node.type_ref.clone();
                                    node = AstNodeWrapper {
                                        node: AstNode::new_selector(&node, &op),
                                        source_ref,
                                        is_lvalue: true,
                                        ..Default::default()
                                    };
                                    if type_ref.pointer == 0 {
                                        return self.parser_error(NodeError(node, String::from("Cannot dereference non-pointer type")));
                                    }
                                    type_ref.pointer -= 1;
                                    node.type_ref = type_ref;
                                }
                                // In case of a procedure call, the node on the left must be an
                                // identifier, and the types of the arguments must match. This is
                                // checked by the function check_procedure
                                ProcedureNode(_, op) => {
                                    let check_result = self.symbol_table.check_procedure(&node, &op);
                                    let tt: TypeWrapper;
                                    match check_result {
                                        Err((n, exp, got)) => {
                                            return self.parser_error(NodeError(n, String::from(format!("expected {}, found {}", exp, got))));
                                        }
                                        Ok(decl) => {
                                            tt = decl.return_type;
                                        }
                                    }
                                    node = AstNodeWrapper {
                                        node: AstNode::new_procedure(&node, &op),
                                        source_ref,
                                        type_ref: tt,
                                        ..Default::default()
                                    };
                                }
                                _ => return Fail,
                            }
                        }
                        Fail => return Fail,
                        Unmatch => break,
                    }
                }
                return Match(node);
            }
            _ => return Fail,
        }
    }

    /// Parser::postfix_operator
    ///
    /// Parse a postfix_operator, defined as
    ///
    /// Postfix_operator -> [ Expression ] Postfix_operator
    ///                   | ( ) Postfix_operator
    ///                   | ( Expression_list ) Postfix_operator
    ///                   | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn postfix_operator(&mut self) -> ParserResult {
        match self.get_current() {
            Tk::Bracket(LSquare) => {
                let token_l = self.get_current_token(true);
                match self.expression() {
                    Match(mut node) => match self.get_current() {
                        Tk::Bracket(RSquare) => {
                            let token_r = self.get_current_token(true);
                            let source_ref = SourceReference::merge(&SourceReference::from_token(&token_l), &SourceReference::from_token(&token_r));
                            node.source_ref = source_ref.clone();
                            let new_node = AstNode::new_selector(&AstNodeWrapper { ..Default::default() }, &node);
                            let result = AstNodeWrapper {
                                node: new_node,
                                source_ref,
                                ..Default::default()
                            };
                            return Match(result);
                        }
                        _ => return self.parser_error(TokenError("]".to_string())),
                    },
                    _ => Fail,
                }
            }
            Tk::Bracket(LBracket) => {
                let token_l = self.get_current_token(true);
                match self.get_current() {
                    Tk::Bracket(RBracket) => {
                        let token_r = self.get_current_token(true);
                        let source_ref = SourceReference::merge(&SourceReference::from_token(&token_l), &SourceReference::from_token(&token_r));
                        let new_node = AstNode::new_procedure(&AstNodeWrapper { ..Default::default() }, &Vec::new());
                        return Match(AstNodeWrapper {
                            node: new_node,
                            source_ref,
                            ..Default::default()
                        });
                    }
                    _ => {}
                }
                match self.expression_list() {
                    Match(node) => return Match(node),
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare)
            | Tk::Operator(LShift)
            | Tk::Operator(RShift)
            | Tk::Operator(Asterisk)
            | Tk::Operator(Slash)
            | Tk::Operator(Module)
            | Tk::Operator(Assign)
            | Tk::Operator(Plus)
            | Tk::Operator(Minus) => return Unmatch,
            _ => return self.parser_error(TokenError("".to_string())),
        }
    }

    /// Parser::primary_expression
    ///
    /// Parse a primary_expression, defined as
    ///
    /// Primary_expression ->   identifier
    ///                     |   number
    ///                     |   char
    ///                     |   ( Expression )
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn primary_expression(&mut self) -> ParserResult {
        match self.get_current() {
            Tk::Identifier(_) | Tk::IntegerLiteral(_) | Tk::Char(_) => {
                let token = self.get_current_token(true);
                let source_ref = SourceReference::from_token(&token);
                let node = AstNode::new_primary(&token);
                let mut result = AstNodeWrapper {
                    node,
                    source_ref,
                    ..Default::default()
                };
                // Integrals are always u32
                if let Tk::IntegerLiteral(_) = token.tk {
                    result.type_ref = TypeWrapper {
                        type_native: TypeNative::U32,
                        ..Default::default()
                    };
                }
                // Char are always u8
                if let Tk::Char(_) = token.tk {
                    result.type_ref = TypeWrapper {
                        type_native: TypeNative::U8,
                        ..Default::default()
                    };
                }
                // Identifiers must be already defined
                if let Tk::Identifier(ref name) = token.tk {
                    let result_search = self.symbol_table.search_definition(&name);
                    if let Err(message) = result_search {
                        return self.parser_error(ParserError::ScopeError(name.to_string(), message, result));
                    }
                    let declaration = result_search.unwrap();
                    result.is_lvalue = true;
                    result.type_ref = declaration.return_type;
                }
                return Match(result);
            }
            // Parenthesis are handled as new expression
            Tk::Bracket(LBracket) => {
                let token_l = self.get_current_token(true);
                match self.expression() {
                    Match(mut node) => match self.get_current() {
                        Tk::Bracket(RBracket) => {
                            let token_r = self.get_current_token(true);
                            let source_ref = SourceReference::merge(&SourceReference::from_token(&token_l), &SourceReference::from_token(&token_r));
                            node.source_ref = source_ref;
                            return Match(node);
                        }
                        _ => return self.parser_error(TokenError(")".to_string())),
                    },
                    _ => return Fail,
                }
            }
            _ => return self.parser_error(TokenError("".to_string())),
        }
    }

    /// Parser::expression_list
    ///
    /// Parse a expression_list, defined as
    ///
    /// Expression_list ->  Expression Expression_list | Expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_list(&mut self) -> ParserResult {
        let mut list: Vec<AstNodeWrapper> = Vec::new();
        let mut source_ref: SourceReference;
        match self.expression() {
            Match(node) => {
                source_ref = node.source_ref.clone();
                list.push(node);
                while self.get_current() == Tk::Operator(Comma) {
                    self.advance();
                    match self.expression() {
                        Match(node) => {
                            list.push(node.clone());
                            source_ref.last_char = node.source_ref.last_char;
                            source_ref.last_line = node.source_ref.last_line;
                        }
                        _ => return Fail,
                    }
                }
                if self.get_current() == Tk::Bracket(RBracket) {
                    self.advance();
                    let node = AstNode::new_procedure(&AstNodeWrapper { ..Default::default() }, &list);
                    return Match(AstNodeWrapper {
                        node,
                        source_ref,
                        ..Default::default()
                    });
                }
                return self.parser_error(TokenError(")".to_string()));
            }
            _ => return Fail,
        }
    }

    /// Parser::parser_error
    ///
    /// Generate an error from the parser
    ///
    /// @in error [ParserError]: type of error to handle
    /// @return [ParseResult]: Always Fail
    fn parser_error(&mut self, error: ParserError) -> ParserResult {
        if self.skip_erorrs {
            return Fail;
        }
        self.errors_counter += 1;
        let line_number = self.token_list[self.current_position].line_number;
        let last_character = self.token_list[self.current_position].last_character;
        let first_character = self.token_list[self.current_position].first_character;
        let file_lines = self.read_lines(&self.file_name);

        eprint!("\x1b[34m{}:{}:{}: \x1b[0m", self.file_name, line_number, first_character);

        match error {
            ScopeError(found, expected, node) => {
                eprintln!(
                    "\x1b[91merror parser: \x1b[0midentifier `\x1b[34m{}\x1b[0m` not found, did you mean `\x1b[34m{}\x1b[0m`?",
                    found, expected
                );
                eprintln!("");
                for line_number in node.source_ref.init_line..=node.source_ref.last_line {
                    let line = &file_lines[line_number as usize - 1];
                    eprint!("{}\t| {}\n\t| ", line_number, line);
                    for i in 0..line.len() {
                        if node.source_ref.init_line == node.source_ref.last_line {
                            if i >= node.source_ref.init_char as usize - 1 && i <= node.source_ref.last_char as usize - 1 {
                                eprint!("\x1b[91m^\x1b[0m");
                            } else {
                                eprint!(" ");
                            }
                        } else if line_number == node.source_ref.init_line {
                            if i < node.source_ref.init_char as usize - 1 {
                                eprint!(" ");
                            } else {
                                eprint!("\x1b[91m^\x1b[0m");
                            }
                        } else if line_number == node.source_ref.last_line {
                            if i <= node.source_ref.last_char as usize - 1 {
                                eprint!("\x1b[91m^\x1b[0m");
                            } else {
                                eprint!(" ");
                            }
                        } else {
                            eprint!("\x1b[91m^\x1b[0m");
                        }
                    }
                    eprintln!("");
                }
            }
            RedefintionError(message) => {
                eprintln!("\x1b[91merror parser: \x1b[0mredefinition of identifier `\x1b[34m{}\x1b[0m`", message);
            }
            TokenError(expected) => {
                if expected.len() != 0 {
                    eprintln!(
                        "\x1b[91merror parser: \x1b[0mexpected `\x1b[34m{}\x1b[0m`, found `\x1b[34m{}\x1b[0m`",
                        expected,
                        self.get_current()
                    );
                } else {
                    eprintln!("\x1b[91merror parser: \x1b[0munexpected token `\x1b[34m{}\x1b[0m`", self.get_current());
                }
                if line_number as usize > file_lines.len() {
                    return Fail;
                }

                eprint!("{}\t| {}\n\t| ", line_number, file_lines[line_number as usize - 1]);

                for i in 0..last_character {
                    if i < first_character - 1 {
                        eprint!(" ");
                    } else if i == first_character - 1 {
                        eprint!("\x1b[91m^\x1b[0m");
                    } else {
                        eprint!("\x1b[91m~\x1b[0m");
                    }
                }
                eprintln!("");
            }
            NodeError(node, string) => {
                eprintln!("\x1b[91merror parser: \x1b[0m{}", string);
                println!("");
                for line_number in node.source_ref.init_line..=node.source_ref.last_line {
                    let line = &file_lines[line_number as usize - 1];
                    eprint!("{}\t| {}\n\t| ", line_number, line);
                    for i in 0..line.len() {
                        if node.source_ref.init_line == node.source_ref.last_line {
                            if i >= node.source_ref.init_char as usize - 1 && i <= node.source_ref.last_char as usize - 1 {
                                eprint!("\x1b[91m^\x1b[0m");
                            } else {
                                eprint!(" ");
                            }
                        } else if line_number == node.source_ref.init_line {
                            if i < node.source_ref.init_char as usize - 1 {
                                eprint!(" ");
                            } else {
                                eprint!("\x1b[91m^\x1b[0m");
                            }
                        } else if line_number == node.source_ref.last_line {
                            if i <= node.source_ref.last_char as usize - 1 {
                                eprint!("\x1b[91m^\x1b[0m");
                            } else {
                                eprint!(" ");
                            }
                        } else {
                            eprint!("\x1b[91m^\x1b[0m");
                        }
                    }
                    eprintln!("");
                }
            }
        }
        return Fail;
    }

    /// Parser::parser_warning
    ///
    /// Generate a warning from the parser
    ///
    /// @in error [ParserError]: type of error to handle
    fn parser_warning(&mut self, error: ParserError) {
        let line_number = self.token_list[self.current_position].line_number;
        let first_character = self.token_list[self.current_position].first_character;
        let file_lines = self.read_lines(&self.file_name);

        eprint!("\x1b[34m{}:{}:{}: \x1b[0m", self.file_name, line_number, first_character);

        match error {
            NodeError(node, string) => {
                eprintln!("\x1b[33mwarning parser: \x1b[0m{}", string);
                println!("");
                for line_number in node.source_ref.init_line..=node.source_ref.last_line {
                    let line = &file_lines[line_number as usize - 1];
                    eprint!("{}\t| {}\n\t| ", line_number, line);
                    for i in 0..line.len() {
                        if node.source_ref.init_line == node.source_ref.last_line {
                            if i >= node.source_ref.init_char as usize - 1 && i <= node.source_ref.last_char as usize - 1 {
                                eprint!("\x1b[33m^\x1b[0m");
                            } else {
                                eprint!(" ");
                            }
                        } else if line_number == node.source_ref.init_line {
                            if i < node.source_ref.init_char as usize - 1 {
                                eprint!(" ");
                            } else {
                                eprint!("\x1b[33m^\x1b[0m");
                            }
                        } else if line_number == node.source_ref.last_line {
                            if i <= node.source_ref.last_char as usize - 1 {
                                eprint!("\x1b[33m^\x1b[0m");
                            } else {
                                eprint!(" ");
                            }
                        } else {
                            eprint!("\x1b[33m^\x1b[0m");
                        }
                    }
                    eprintln!("");
                }
            }
            _ => {}
        }
    }

    /// Parser::read_lines
    ///
    /// Get all the linest from a required source file
    ///
    /// @in expected [&str]: file name
    /// @return [Vec<String>]: vector of all the strings in the file
    fn read_lines(&self, filename: &str) -> Vec<String> {
        let mut result = Vec::new();

        for line in read_to_string(filename).unwrap().lines() {
            result.push(line.to_string())
        }

        result
    }
}
