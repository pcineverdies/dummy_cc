use crate::lexer::lexer_impl::{Bracket, Keyword, Operator, Tk, Token};
use crate::parser::resolution::Resolution;
use std::string::String;
use std::{fs::read_to_string, process::exit};

macro_rules! debug_println {
    ($($arg:tt)*) => (if ::std::cfg!(debug_assertions) { ::std::println!($($arg)*); })
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Parser {
    token_list: Vec<Token>,
    current_position: usize,
    depth: u32,
    errors_counter: u32,
    file_name: String,
    resolution: Resolution,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserResult {
    Match,
    Unmatch,
    Fail,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserErrorType {
    ScopeError,
    TokenError,
}

use Bracket::*;
use Keyword::*;
use Operator::*;
use ParserErrorType::*;
use ParserResult::*;
use Tk::*;

impl Parser {
    //! Parser::new
    //!
    //! Initiate the parser with a vector of tokens generated by the lexer
    //!
    //! @input token_list [Vec<Token>]: List of input tokens
    //! @input file_name [String]: Name of the file under analysis
    //! @return [Parser]: Generated parser
    pub fn new(token_list: Vec<Token>, file_name: String) -> Parser {
        Parser {
            token_list,
            current_position: 0,
            depth: 0,
            errors_counter: 0,
            file_name,
            resolution: Resolution::new(),
        }
    }

    /// Parser::get_current
    ///
    /// Get the current token under exam
    fn get_current(&self) -> Tk {
        return self.token_list[self.current_position].clone().tk;
    }

    /// Parser::get_current_token
    ///
    /// Get the full current token under exam
    fn get_current_token(&mut self) -> Token {
        return self.token_list[self.current_position].clone();
    }

    /// Parser::previous
    ///
    /// Go to previous token
    fn previous(&mut self) {
        self.current_position -= 1;
        debug_println!("Restoring {:?}", self.get_current());
    }

    /// Parser::advance
    ///
    /// Advance to next token
    fn advance(&mut self) {
        debug_println!("Consuming {:?}", self.get_current());
        self.current_position += 1;
        if self.current_position as usize >= self.token_list.len() {
            eprintln!(
                "\x1b[91mFailed parsing with {} errors\x1b[0m",
                self.errors_counter
            );
            exit(1);
        }
    }

    /// Parser::parse
    ///
    /// Parse the list of token provided to the parser during initialization
    ///
    /// @return [Option<()>]: return the AST in case of success, None if an error occurred in the
    /// process
    pub fn parse(&mut self) -> Option<()> {
        debug_println!("-> parse");

        match self.expression() {
            Match => {
                if self.get_current() != Tk::Semicolon {
                    self.parser_error("", TokenError);
                    return None;
                } else if self.errors_counter > 0 {
                    return None;
                } else {
                    return Some(());
                }
            }
            _ => {
                return None;
            }
        }
    }

    /// Parser::expression
    ///
    /// Parse an expression, defined as
    ///
    /// Expression ->    Logical_expression
    ///             |    Unary_expression = Expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression(&mut self) -> ParserResult {
        debug_println!("-> expression");

        match self.logical_expression() {
            Match => return Match,
            Fail => return Fail,
            _ => {}
        }
        match self.unary_expression() {
            Match => match self.get_current() {
                Operator(Assign) => {
                    self.advance();
                    match self.expression() {
                        Match => return Match,
                        _ => return Fail,
                    }
                }
                _ => return Fail,
            },
            _ => return Fail,
        }
    }

    /// Parser::logical_expression
    ///
    /// Parse a logical_expression, defined as
    ///
    /// Logical_expression ->   Equality_expression Logical_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn logical_expression(&mut self) -> ParserResult {
        debug_println!("-> logical_expression");
        match self.equality_expression() {
            Match => match self.logical_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::logical_expression_star
    ///
    /// Parse a logical_expression_star, defined as
    ///
    ///
    /// Logical_expression_star -> & Logical_expression
    ///                          | | Logical_expression
    ///                          | ^ Logical_expression
    ///                          | and Logical_expression
    ///                          | or Logical_expression
    ///                          | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn logical_expression_star(&mut self) -> ParserResult {
        debug_println!("-> logical_expression_star");
        match self.get_current() {
            Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or) => {
                self.advance();
                match self.logical_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket) | Tk::Semicolon | Tk::Bracket(RSquare) | Tk::Operator(Comma) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::equality_expression
    ///
    /// Parse an equality_expression, defined as
    ///
    /// Equality_expression ->   Relational_expression Equality_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn equality_expression(&mut self) -> ParserResult {
        debug_println!("-> equality_expression");
        match self.relational_expression() {
            Match => match self.equality_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::equality_expression_star
    ///
    /// Parse a equality_expression_star, defined as
    ///
    /// Equality_expression_star -> == Equality_expression
    ///                           | != Equality_expression
    ///                           | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn equality_expression_star(&mut self) -> ParserResult {
        debug_println!("-> equality_expression_star");
        match self.get_current() {
            Tk::Operator(EqualCompare) | Tk::Operator(DiffCompare) => {
                self.advance();
                match self.equality_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::relational_expression
    ///
    /// Parse a relational_expression, defined as
    ///
    /// Relational_expression ->    Shift_expression Relational_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn relational_expression(&mut self) -> ParserResult {
        debug_println!("-> relational_expression");
        match self.shift_expression() {
            Match => match self.relational_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::relational_expression_star
    ///
    /// Parse a relational_expression_star, defined as
    ///
    /// Relational_expression_star ->   > Relational_expression
    ///                             |   < Relational_expression
    ///                             |   >= Relational_expression
    ///                             |   <= Relational_expression
    ///                             |   ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn relational_expression_star(&mut self) -> ParserResult {
        debug_println!("-> relational_expression_star");
        match self.get_current() {
            Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare) => {
                self.advance();
                match self.relational_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::shift_expression
    ///
    /// Parse a shift_expression, defined as
    ///
    /// Shift_expression -> Additive_expression Shift_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn shift_expression(&mut self) -> ParserResult {
        debug_println!("-> shift_expression");
        match self.additive_expression() {
            Match => match self.shift_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::shift_expression_star
    ///
    /// Parse a shift_expression_star, defined as
    ///
    /// Shift_expression_star ->    << Shift_expression
    ///                        |    >> Shift_expression
    ///                        |    ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn shift_expression_star(&mut self) -> ParserResult {
        debug_println!("-> shift_expression_star");
        match self.get_current() {
            Tk::Operator(LShift) | Tk::Operator(RShift) => {
                self.advance();
                match self.shift_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::additive_expression
    ///
    /// Parse a additive_expression, defined as
    ///
    /// Additive_expression -> Multiplicative_expression Additive_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn additive_expression(&mut self) -> ParserResult {
        debug_println!("-> additive_expression");
        match self.multiplicative_expression() {
            Match => match self.additive_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::additive_expression_star
    ///
    /// Parse a additive_expression_star, defined as
    ///
    /// Additive_expression_star -> + Additive_expression
    ///                           | - Additive_expression
    ///                           | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn additive_expression_star(&mut self) -> ParserResult {
        debug_println!("-> additive_expression_star");
        match self.get_current() {
            Tk::Operator(Plus) | Tk::Operator(Minus) => {
                self.advance();
                match self.additive_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare)
            | Tk::Operator(LShift)
            | Tk::Operator(RShift) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::multiplicative_expression
    ///
    /// Parse a multiplicative_expression, defined as
    ///
    /// Multiplicative_expression -> Cast_expression Multiplicative_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn multiplicative_expression(&mut self) -> ParserResult {
        debug_println!("-> multiplicative_expression");
        match self.cast_expression() {
            Match => match self.multiplicative_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::multiplicative_expression_star
    ///
    /// Parse a multiplicative_expression_star, defined as
    ///
    /// Multiplicative_expression_star ->   * Multiplicative_expression
    ///                                 |   / Multiplicative_expression
    ///                                 |   % Multiplicative_expression
    ///                                 |   ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn multiplicative_expression_star(&mut self) -> ParserResult {
        debug_println!("-> multiplicative_expression_star");
        match self.get_current() {
            Tk::Operator(Asterisk) | Tk::Operator(Slash) | Tk::Operator(Module) => {
                self.advance();
                match self.multiplicative_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare)
            | Tk::Operator(LShift)
            | Tk::Operator(RShift)
            | Tk::Operator(Plus)
            | Tk::Operator(Minus) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::cast_expression
    ///
    /// Parse a cast_expression, defined as
    ///
    /// Cast_expression ->  ( Pointer_type ) Cast_expression
    ///                  |  Unary_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn cast_expression(&mut self) -> ParserResult {
        debug_println!("-> cast_expression");
        match self.get_current() {
            Tk::Bracket(LBracket) => {
                self.advance();
                if self.get_current().is_type() {
                    match self.pointer_type() {
                        Match => match self.get_current() {
                            Tk::Bracket(RBracket) => {
                                self.advance();
                                match self.cast_expression() {
                                    Match => return Match,
                                    _ => return Fail,
                                }
                            }
                            _ => return self.parser_error(")", TokenError),
                        },
                        Unmatch => {
                            self.previous();
                        }
                        _ => return Fail,
                    }
                } else {
                    self.previous();
                }
            }
            _ => {}
        }
        match self.unary_expression() {
            Match => Match,
            _ => Fail,
        }
    }

    /// Parser::pointer_type
    ///
    /// Parse a pointer_type, defined as
    ///
    /// Pointer_type -> Type_native Pointer
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn pointer_type(&mut self) -> ParserResult {
        debug_println!("-> pointer_type");
        match self.type_native() {
            Match => match self.pointer() {
                Match => Match,
                Unmatch => Match,
                Fail => Fail,
            },
            _ => Unmatch,
        }
    }

    /// Parser::pointer
    ///
    /// Parse a pointer, defined as
    ///
    /// Pointer -> * Pointer
    ///          | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn pointer(&mut self) -> ParserResult {
        debug_println!("-> pointer");
        match self.get_current() {
            Tk::Operator(Asterisk) => {
                self.advance();
                match self.pointer() {
                    Fail => return Fail,
                    Match => return Match,
                    Unmatch => return Unmatch,
                }
            }
            Tk::Identifier(_) => return Unmatch,
            Tk::Bracket(RBracket) => return Unmatch,
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::type_native
    ///
    /// Parse a type_native, defined as
    ///
    /// Type_native -> u8 | u16 | u32 | i8 | i16 | i32 | void
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn type_native(&mut self) -> ParserResult {
        debug_println!("-> type_native");
        match self.get_current() {
            Tk::Keyword(U8)
            | Tk::Keyword(U16)
            | Tk::Keyword(U32)
            | Tk::Keyword(I8)
            | Tk::Keyword(I16)
            | Tk::Keyword(I32)
            | Tk::Keyword(Void) => {
                self.advance();
                return Match;
            }
            _ => return Fail,
        }
    }

    /// Parser::unary_expression
    ///
    /// Parse a unary_expression, defined as
    ///
    /// Unary_expression -> Postfix_expression
    ///                   | + Unary_expression
    ///                   | - Unary_expression
    ///                   | ! Unary_expression
    ///                   | & Unary_expression
    ///                   | * Unary_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn unary_expression(&mut self) -> ParserResult {
        debug_println!("-> unary_expression");
        match self.get_current() {
            Tk::Operator(Plus)
            | Tk::Operator(Minus)
            | Tk::Operator(Complement)
            | Tk::Operator(AndOp)
            | Tk::Operator(Asterisk) => {
                self.advance();
                match self.unary_expression() {
                    Match => Match,
                    _ => Fail,
                }
            }
            _ => match self.postfix_expression() {
                Match => Match,
                _ => Fail,
            },
        }
    }

    /// Parser::postfix_expression
    ///
    /// Parse a postfix_expression, defined as
    ///
    /// Postfix_expression ->   Primary_expression  Postfix_operator
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn postfix_expression(&mut self) -> ParserResult {
        debug_println!("-> postfix_expression");
        match self.primary_expression() {
            Match => match self.postfix_operator() {
                Match => return Match,
                Unmatch => return Match,
                Fail => return Fail,
            },
            _ => return Fail,
        }
    }

    /// Parser::postfix_operator
    ///
    /// Parse a postfix_operator, defined as
    ///
    /// Postfix_operator -> [ Expression ] Postfix_operator
    ///                   | ( ) Postfix_operator
    ///                   | ( Expression_list ) Postfix_operator
    ///                   | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn postfix_operator(&mut self) -> ParserResult {
        debug_println!("-> postfix_operator");
        match self.get_current() {
            Tk::Bracket(LSquare) => {
                self.advance();
                match self.expression() {
                    Match => match self.get_current() {
                        Tk::Bracket(RSquare) => {
                            self.advance();
                            match self.postfix_operator() {
                                Fail => Fail,
                                Unmatch => Match,
                                Match => Match,
                            }
                        }
                        _ => return self.parser_error("]", TokenError),
                    },
                    _ => Fail,
                }
            }
            Tk::Bracket(LBracket) => {
                self.advance();
                match self.get_current() {
                    Tk::Bracket(RBracket) => {
                        self.advance();
                        match self.postfix_operator() {
                            Fail => return Fail,
                            Unmatch => return Match,
                            Match => return Match,
                        }
                    }
                    _ => {}
                }
                match self.expression_list() {
                    Match => match self.get_current() {
                        Tk::Bracket(RBracket) => {
                            self.advance();
                            match self.postfix_operator() {
                                Fail => return Fail,
                                Unmatch => return Match,
                                Match => return Match,
                            }
                        }
                        _ => return self.parser_error(")", TokenError),
                    },
                    _ => Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare)
            | Tk::Operator(LShift)
            | Tk::Operator(RShift)
            | Tk::Operator(Asterisk)
            | Tk::Operator(Slash)
            | Tk::Operator(Module)
            | Tk::Operator(Assign)
            | Tk::Operator(Plus)
            | Tk::Operator(Minus) => return Unmatch,
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::primary_expression
    ///
    /// Parse a primary_expression, defined as
    ///
    /// Primary_expression ->   identifier
    ///                     |   number
    ///                     |   char
    ///                     |   ( Expression )
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn primary_expression(&mut self) -> ParserResult {
        debug_println!("-> primary_expression");
        match self.get_current() {
            Tk::Identifier(_) => {
                self.advance();
                return Match;
            }
            Tk::IntegerLiteral(_) => {
                self.advance();
                return Match;
            }
            Tk::Char(_) => {
                self.advance();
                return Match;
            }
            Tk::Bracket(LBracket) => {
                self.advance();
                match self.expression() {
                    Match => match self.get_current() {
                        Tk::Bracket(RBracket) => {
                            self.advance();
                            return Match;
                        }
                        _ => return self.parser_error(")", TokenError),
                    },
                    _ => return Fail,
                }
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::expression_list
    ///
    /// Parse a expression_list, defined as
    ///
    /// Expression_list ->  Expression Expression_list_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_list(&mut self) -> ParserResult {
        debug_println!("-> expression_list");
        match self.expression() {
            Match => match self.expression_list_star() {
                Match => Match,
                Fail => Fail,
                Unmatch => Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::expression_list_star
    ///
    /// Parse a expression_list_star, defined as
    ///
    /// Expression_list_star -> , Expression_list
    ///                       | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_list_star(&mut self) -> ParserResult {
        debug_println!("-> expression_list_star");
        match self.get_current() {
            Tk::Operator(Comma) => {
                self.advance();
                match self.expression_list() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket) => return Unmatch,
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::parser_error
    ///
    /// Generate an error from the parser
    ///
    /// @in expected [&str]: string to give some information about the error
    /// @in error [ParserErrorType]: type of error to handle
    /// @return [ParseResult]: Always Fail
    fn parser_error(&mut self, expected: &str, error: ParserErrorType) -> ParserResult {
        self.errors_counter += 1;
        let line_number = self.token_list[self.current_position].line_number;
        let last_character = self.token_list[self.current_position].last_character;
        let first_character = self.token_list[self.current_position].first_character;
        let file_lines = self.read_lines(&self.file_name);

        eprint!(
            "\x1b[34m{}:{}:{}: \x1b[0m",
            self.file_name, line_number, first_character
        );

        match error {
            TokenError => {
                if expected.len() != 0 {
                    eprintln!(
                        "\x1b[91merror parser: \x1b[0mexpected `\x1b[34m{}\x1b[0m`, found `\x1b[34m{}\x1b[0m`",
                        expected,
                        self.get_current()
                    );
                } else {
                    eprintln!(
                        "\x1b[91merror parser: \x1b[0munexpected token `\x1b[34m{}\x1b[0m`",
                        self.get_current()
                    );
                }
            }
            _ => {}
        }
        if line_number as usize > file_lines.len() {
            return Fail;
        }

        eprint!(
            "{}\t| {}\n\t| ",
            line_number,
            file_lines[line_number as usize - 1]
        );

        for i in 0..last_character {
            if i < first_character - 1 {
                eprint!(" ");
            } else if i == first_character - 1 {
                eprint!("\x1b[91m^\x1b[0m");
            } else {
                eprint!("\x1b[91m~\x1b[0m");
            }
        }
        eprintln!("");

        return Fail;
    }

    fn read_lines(&self, filename: &str) -> Vec<String> {
        let mut result = Vec::new();

        for line in read_to_string(filename).unwrap().lines() {
            result.push(line.to_string())
        }

        result
    }
}
