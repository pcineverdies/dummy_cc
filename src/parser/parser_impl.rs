use crate::lexer::lexer_impl::{Bracket, Keyword, Operator, Tk, Token};
use std::{fs::read_to_string, process::exit};

macro_rules! debug_println {
    ($($arg:tt)*) => (if ::std::cfg!(debug_assertions) { ::std::println!($($arg)*); })
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Parser {
    token_list: Vec<Token>,
    current_position: usize,
    depth: u32,
    errors_counter: u32,
    file_name: String,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserResult {
    Match,
    Unmatch,
    Fail,
}

impl Parser {
    //! Parser::new
    //!
    //! Initiate the parser with a vector of tokens generated by the lexer
    //!
    //! @input token_list [Vec<Token>]: List of input tokens
    //! @input file_name [String]: Name of the file under analysis
    //! @return [Parser]: Generated parser
    pub fn new(token_list: Vec<Token>, file_name: String) -> Parser {
        Parser {
            token_list,
            current_position: 0,
            depth: 0,
            errors_counter: 0,
            file_name,
        }
    }

    /// Parser::get_current
    ///
    /// Get the current token under exam
    fn get_current(&mut self) -> Tk {
        return self.token_list[self.current_position].clone().tk;
    }

    /// Parser::advance
    ///
    /// Advance to next token
    fn advance(&mut self) {
        debug_println!("Consuming {:?}", self.get_current());
        self.current_position += 1;
        if self.current_position as usize >= self.token_list.len() {
            eprintln!("PARSER ERROR: Token index out of bound");
            exit(1);
        }
    }

    pub fn parse(&mut self) {
        debug_println!("-> parse");
        if self.statement_list() == ParserResult::Match {
            if self.get_current() != Tk::EOF {
                self.parser_error("EOF");
            } else {
                debug_println!("\x1b[92mParsing succesfull\x1b[0m");
                return;
            }
        }
        eprintln!(
            "\x1b[91mFailed parsing with {} errors\x1b[0m",
            self.errors_counter
        );
    }

    fn statement_list(&mut self) -> ParserResult {
        debug_println!("-> statement_list");
        if self.statement() == ParserResult::Match {
            return self.statement_list_star();
        }
        while self.get_current() != Tk::Semicolon
            && self.get_current() != Tk::Bracket(Bracket::RCurly)
        {
            self.advance();
        }
        self.advance();
        return self.statement_list();
    }

    fn statement_list_star(&mut self) -> ParserResult {
        debug_println!("-> statement_list_star");
        match self.get_current() {
            Tk::Bracket(Bracket::RCurly) => return ParserResult::Match,
            Tk::EOF => return ParserResult::Match,
            _ => return self.statement_list(),
        }
    }

    fn statement(&mut self) -> ParserResult {
        debug_println!("-> statement");
        match self.variable_declaration() {
            ParserResult::Match => {
                if self.get_current() != Tk::Semicolon {
                    return self.parser_error(";");
                }
                self.advance();
                return ParserResult::Match;
            }
            ParserResult::Fail => return ParserResult::Fail,
            _ => {}
        }

        match self.for_statement() {
            ParserResult::Match => return ParserResult::Match,
            ParserResult::Fail => return ParserResult::Fail,
            _ => {}
        }

        match self.flow_statement() {
            ParserResult::Match => return ParserResult::Match,
            ParserResult::Fail => return ParserResult::Fail,
            _ => {}
        }

        match self.if_statement() {
            ParserResult::Match => return ParserResult::Match,
            ParserResult::Fail => return ParserResult::Fail,
            _ => {}
        }

        match self.while_statement() {
            ParserResult::Match => return ParserResult::Match,
            ParserResult::Fail => return ParserResult::Fail,
            _ => {}
        }

        match self.assignment_statement() {
            ParserResult::Match => return ParserResult::Match,
            ParserResult::Fail => return ParserResult::Fail,
            _ => {}
        }

        match self.get_current() {
            Tk::Semicolon => {
                self.advance();
                return ParserResult::Match;
            }
            Tk::Identifier(_) => return ParserResult::Match,
            Tk::Bracket(Bracket::RCurly) => return ParserResult::Match,
            Tk::EOF => return ParserResult::Match,
            Tk::Keyword(Keyword::If) => return ParserResult::Match,
            Tk::Keyword(Keyword::For) => return ParserResult::Match,
            Tk::Keyword(Keyword::Return) => return ParserResult::Match,
            Tk::Keyword(Keyword::Continue) => return ParserResult::Match,
            Tk::Keyword(Keyword::Break) => return ParserResult::Match,
            Tk::Keyword(Keyword::Char) => return ParserResult::Match,
            Tk::Keyword(Keyword::Int) => return ParserResult::Match,
            Tk::Keyword(Keyword::Bool) => return ParserResult::Match,
            Tk::Keyword(Keyword::While) => return ParserResult::Match,
            _ => {
                return self.parser_error(
                    "one of {identifier, eof, ), for, while, return, break, continue, char, int, bool, if}",
                );
            }
        }
    }

    fn flow_statement(&mut self) -> ParserResult {
        if self.get_current() == Tk::Keyword(Keyword::Continue) {
            self.advance();
            if self.get_current() == Tk::Semicolon {
                self.advance();
                return ParserResult::Match;
            }

            return self.parser_error(";");
        }

        if self.get_current() == Tk::Keyword(Keyword::Break) {
            self.advance();
            if self.get_current() == Tk::Semicolon {
                self.advance();
                return ParserResult::Match;
            }

            return self.parser_error(";");
        }

        if self.get_current() == Tk::Keyword(Keyword::Return) {
            self.advance();
            if self.get_current() == Tk::Semicolon {
                self.advance();
                return ParserResult::Match;
            }
            if self.expr() != ParserResult::Match {
                return ParserResult::Fail;
            }
            if self.get_current() == Tk::Semicolon {
                self.advance();
                return ParserResult::Match;
            }

            return self.parser_error(";");
        }

        return ParserResult::Unmatch;
    }

    fn for_statement(&mut self) -> ParserResult {
        debug_println!("-> for_statement");
        if self.get_current() != Tk::Keyword(Keyword::For) {
            return ParserResult::Unmatch;
        }
        self.advance();
        if self.get_current() != Tk::Bracket(Bracket::LBracket) {
            return self.parser_error("(");
        }
        self.advance();
        if self.variable_declaration() != ParserResult::Match {
            return ParserResult::Fail;
        }
        if self.get_current() != Tk::Semicolon {
            return self.parser_error(";");
        }
        self.advance();
        if self.expr() != ParserResult::Match {
            return ParserResult::Fail;
        }
        if self.get_current() != Tk::Semicolon {
            return self.parser_error(";");
        }
        self.advance();
        if self.assignment_statement() != ParserResult::Match {
            return ParserResult::Fail;
        }
        if self.get_current() != Tk::Bracket(Bracket::RBracket) {
            return self.parser_error(")");
        }
        self.advance();
        if self.get_current() != Tk::Bracket(Bracket::LCurly) {
            return self.parser_error("{");
        }
        self.advance();
        if self.statement_list() == ParserResult::Fail {
            return ParserResult::Fail;
        }
        if self.get_current() != Tk::Bracket(Bracket::RCurly) {
            return self.parser_error("}");
        }
        self.advance();
        return self.else_statement();
    }

    fn variable_declaration(&mut self) -> ParserResult {
        debug_println!("-> variable_declaration");
        if self.get_current() != Tk::Keyword(Keyword::Char)
            && self.get_current() != Tk::Keyword(Keyword::Bool)
            && self.get_current() != Tk::Keyword(Keyword::Int)
        {
            return ParserResult::Unmatch;
        }
        self.advance();
        match self.get_current() {
            Tk::Identifier(_) => {
                self.advance();
                if self.get_current() != Tk::Operator(Operator::Assign) {
                    return self.parser_error("=");
                }
                self.advance();
                return self.expr();
            }
            _ => {
                return self.parser_error("identifier");
            }
        }
    }

    fn if_statement(&mut self) -> ParserResult {
        debug_println!("-> if_statement");
        if self.get_current() != Tk::Keyword(Keyword::If) {
            return ParserResult::Unmatch;
        }
        self.advance();
        if self.get_current() != Tk::Bracket(Bracket::LBracket) {
            return self.parser_error("(");
        }
        self.advance();
        if self.expr() != ParserResult::Match {
            return ParserResult::Fail;
        }
        if self.get_current() != Tk::Bracket(Bracket::RBracket) {
            return self.parser_error(")");
        }
        self.advance();
        if self.get_current() != Tk::Bracket(Bracket::LCurly) {
            return self.parser_error("{");
        }
        self.advance();
        if self.statement_list() == ParserResult::Fail {
            return ParserResult::Fail;
        }
        if self.get_current() != Tk::Bracket(Bracket::RCurly) {
            return self.parser_error("}");
        }
        self.advance();
        if self.else_statement() == ParserResult::Fail {
            return ParserResult::Fail;
        }
        return ParserResult::Match;
    }

    fn while_statement(&mut self) -> ParserResult {
        debug_println!("-> while_statement");
        if self.get_current() != Tk::Keyword(Keyword::While) {
            return ParserResult::Unmatch;
        }
        self.advance();
        if self.get_current() != Tk::Bracket(Bracket::LBracket) {
            return self.parser_error("(");
        }
        self.advance();
        if self.expr() != ParserResult::Match {
            return ParserResult::Fail;
        }
        if self.get_current() != Tk::Bracket(Bracket::RBracket) {
            return self.parser_error(")");
        }
        self.advance();
        if self.get_current() != Tk::Bracket(Bracket::LCurly) {
            return self.parser_error("{");
        }
        self.advance();
        if self.statement_list() == ParserResult::Fail {
            return ParserResult::Fail;
        }
        if self.get_current() != Tk::Bracket(Bracket::RCurly) {
            return self.parser_error("}");
        }
        self.advance();
        if self.else_statement() == ParserResult::Fail {
            return ParserResult::Fail;
        }
        return ParserResult::Match;
    }

    fn else_statement(&mut self) -> ParserResult {
        if self.get_current() == Tk::Keyword(Keyword::Else) {
            self.advance();
            if self.get_current() != Tk::Bracket(Bracket::LCurly) {
                return self.parser_error("{");
            }
            self.advance();
            if self.statement_list() == ParserResult::Fail {
                return ParserResult::Fail;
            }
            if self.get_current() != Tk::Bracket(Bracket::RCurly) {
                return self.parser_error("}");
            }
            self.advance();
            return ParserResult::Match;
        } else {
            match self.get_current() {
                Tk::Identifier(_) => return ParserResult::Match,
                Tk::EOF => return ParserResult::Match,
                Tk::Bracket(Bracket::RCurly) => return ParserResult::Match,
                Tk::Semicolon => return ParserResult::Match,
                Tk::Keyword(Keyword::For) => return ParserResult::Match,
                Tk::Keyword(Keyword::While) => return ParserResult::Match,
                Tk::Keyword(Keyword::Return) => return ParserResult::Match,
                Tk::Keyword(Keyword::Break) => return ParserResult::Match,
                Tk::Keyword(Keyword::Continue) => return ParserResult::Match,
                Tk::Keyword(Keyword::Char) => return ParserResult::Match,
                Tk::Keyword(Keyword::Int) => return ParserResult::Match,
                Tk::Keyword(Keyword::Bool) => return ParserResult::Match,
                Tk::Keyword(Keyword::If) => return ParserResult::Match,
                _ => {
                    return self.parser_error("one of {identifier, eof, ), for, while, return, break, continue, char, int, bool, if}");
                }
            }
        }
    }

    fn assignment_statement(&mut self) -> ParserResult {
        debug_println!("-> assignment_statement");
        match self.get_current() {
            Tk::Identifier(_) => {
                self.advance();
                if self.get_current() != Tk::Operator(Operator::Assign) {
                    return self.parser_error("=");
                }
                self.advance();
                return self.expr();
            }
            _ => {
                return ParserResult::Unmatch;
            }
        }
    }

    fn expr(&mut self) -> ParserResult {
        debug_println!("-> expr");
        return self.equality();
    }

    fn equality(&mut self) -> ParserResult {
        debug_println!("-> equality");
        if self.comparison() == ParserResult::Match {
            return self.equality_star();
        } else {
            return ParserResult::Fail;
        }
    }

    fn equality_star(&mut self) -> ParserResult {
        debug_println!("-> equality_star");
        if self.get_current() == Tk::Operator(Operator::EqualCompare)
            || self.get_current() == Tk::Operator(Operator::DiffCompare)
        {
            self.advance();
            return self.expr();
        } else if self.get_current() == Tk::Bracket(Bracket::RBracket)
            || self.get_current() == Tk::Semicolon
            || self.get_current() == Tk::Operator(Operator::EqualCompare)
            || self.get_current() == Tk::Operator(Operator::DiffCompare)
            || self.get_current() == Tk::Operator(Operator::LTCompare)
            || self.get_current() == Tk::Operator(Operator::GTCompare)
            || self.get_current() == Tk::Operator(Operator::LECompare)
            || self.get_current() == Tk::Operator(Operator::GECompare)
            || self.get_current() == Tk::Operator(Operator::Xor)
            || self.get_current() == Tk::Operator(Operator::Or)
            || self.get_current() == Tk::Operator(Operator::And)
            || self.get_current() == Tk::Operator(Operator::Minus)
            || self.get_current() == Tk::Operator(Operator::Plus)
            || self.get_current() == Tk::Operator(Operator::Slash)
            || self.get_current() == Tk::Operator(Operator::Asterisk)
        {
            return ParserResult::Match;
        } else {
            return self
                .parser_error("one of {), ; , ==, !=, <, >, >=, <=, ^, ||, &&, -, +, /, *}");
        }
    }

    fn comparison(&mut self) -> ParserResult {
        debug_println!("-> comparison");
        if self.term() == ParserResult::Match {
            return self.comparison_star();
        } else {
            return ParserResult::Fail;
        }
    }

    fn comparison_star(&mut self) -> ParserResult {
        debug_println!("-> comparison_star");
        if self.get_current() == Tk::Operator(Operator::LTCompare)
            || self.get_current() == Tk::Operator(Operator::GTCompare)
            || self.get_current() == Tk::Operator(Operator::GECompare)
            || self.get_current() == Tk::Operator(Operator::LECompare)
        {
            self.advance();
            return self.expr();
        } else if self.get_current() == Tk::Bracket(Bracket::RBracket)
            || self.get_current() == Tk::Semicolon
            || self.get_current() == Tk::Operator(Operator::EqualCompare)
            || self.get_current() == Tk::Operator(Operator::DiffCompare)
            || self.get_current() == Tk::Operator(Operator::LTCompare)
            || self.get_current() == Tk::Operator(Operator::GTCompare)
            || self.get_current() == Tk::Operator(Operator::LECompare)
            || self.get_current() == Tk::Operator(Operator::GECompare)
            || self.get_current() == Tk::Operator(Operator::Xor)
            || self.get_current() == Tk::Operator(Operator::Or)
            || self.get_current() == Tk::Operator(Operator::And)
            || self.get_current() == Tk::Operator(Operator::Minus)
            || self.get_current() == Tk::Operator(Operator::Plus)
            || self.get_current() == Tk::Operator(Operator::Slash)
            || self.get_current() == Tk::Operator(Operator::Asterisk)
        {
            return ParserResult::Match;
        } else {
            return self
                .parser_error("one of {), ; , ==, !=, <, >, >=, <=, ^, ||, &&, -, +, /, *}");
        }
    }

    fn term(&mut self) -> ParserResult {
        debug_println!("-> term");
        if self.factor() == ParserResult::Match {
            return self.term_star();
        } else {
            return ParserResult::Fail;
        }
    }

    fn term_star(&mut self) -> ParserResult {
        debug_println!("-> term_star");
        if self.get_current() == Tk::Operator(Operator::Plus)
            || self.get_current() == Tk::Operator(Operator::Minus)
            || self.get_current() == Tk::Operator(Operator::Or)
            || self.get_current() == Tk::Operator(Operator::And)
            || self.get_current() == Tk::Operator(Operator::Xor)
        {
            self.advance();
            return self.expr();
        } else if self.get_current() == Tk::Bracket(Bracket::RBracket)
            || self.get_current() == Tk::Semicolon
            || self.get_current() == Tk::Operator(Operator::EqualCompare)
            || self.get_current() == Tk::Operator(Operator::DiffCompare)
            || self.get_current() == Tk::Operator(Operator::LTCompare)
            || self.get_current() == Tk::Operator(Operator::GTCompare)
            || self.get_current() == Tk::Operator(Operator::LECompare)
            || self.get_current() == Tk::Operator(Operator::GECompare)
            || self.get_current() == Tk::Operator(Operator::Xor)
            || self.get_current() == Tk::Operator(Operator::Or)
            || self.get_current() == Tk::Operator(Operator::And)
            || self.get_current() == Tk::Operator(Operator::Minus)
            || self.get_current() == Tk::Operator(Operator::Plus)
            || self.get_current() == Tk::Operator(Operator::Slash)
            || self.get_current() == Tk::Operator(Operator::Asterisk)
        {
            return ParserResult::Match;
        } else {
            return self
                .parser_error("one of {), ; , ==, !=, <, >, >=, <=, ^, ||, &&, -, +, /, *}");
        }
    }

    fn factor(&mut self) -> ParserResult {
        debug_println!("-> factor");
        if self.unary() == ParserResult::Match {
            return self.factor_star();
        } else {
            return ParserResult::Fail;
        }
    }

    fn factor_star(&mut self) -> ParserResult {
        debug_println!("-> factor_star");
        if self.get_current() == Tk::Operator(Operator::Module)
            || self.get_current() == Tk::Operator(Operator::Slash)
            || self.get_current() == Tk::Operator(Operator::Module)
            || self.get_current() == Tk::Operator(Operator::Asterisk)
        {
            self.advance();
            return self.expr();
        } else if self.get_current() == Tk::Bracket(Bracket::RBracket)
            || self.get_current() == Tk::Semicolon
            || self.get_current() == Tk::Operator(Operator::EqualCompare)
            || self.get_current() == Tk::Operator(Operator::DiffCompare)
            || self.get_current() == Tk::Operator(Operator::LTCompare)
            || self.get_current() == Tk::Operator(Operator::GTCompare)
            || self.get_current() == Tk::Operator(Operator::LECompare)
            || self.get_current() == Tk::Operator(Operator::GECompare)
            || self.get_current() == Tk::Operator(Operator::Xor)
            || self.get_current() == Tk::Operator(Operator::Or)
            || self.get_current() == Tk::Operator(Operator::And)
            || self.get_current() == Tk::Operator(Operator::Minus)
            || self.get_current() == Tk::Operator(Operator::Plus)
            || self.get_current() == Tk::Operator(Operator::Slash)
            || self.get_current() == Tk::Operator(Operator::Asterisk)
        {
            return ParserResult::Match;
        } else {
            return self
                .parser_error("one of {), ; , ==, !=, <, >, >=, <=, ^, ||, &&, -, +, /, *}");
        }
    }

    fn unary(&mut self) -> ParserResult {
        debug_println!("-> unary");
        if self.get_current() == Tk::Operator(Operator::Plus)
            || self.get_current() == Tk::Operator(Operator::Minus)
            || self.get_current() == Tk::Operator(Operator::Not)
            || self.get_current() == Tk::Operator(Operator::Complement)
        {
            self.advance();
            return self.expr();
        }
        return self.primary();
    }

    fn primary(&mut self) -> ParserResult {
        debug_println!("-> primary");
        match self.get_current() {
            Tk::IntegerLiteral(_) => {
                self.advance();
                return ParserResult::Match;
            }
            Tk::Identifier(_) => {
                self.advance();
                return ParserResult::Match;
            }
            Tk::Char(_) => {
                self.advance();
                return ParserResult::Match;
            }
            Tk::Keyword(Keyword::True) | Tk::Keyword(Keyword::False) => {
                self.advance();
                return ParserResult::Match;
            }
            Tk::Bracket(Bracket::LBracket) => {
                self.advance();
                if self.expr() == ParserResult::Match {
                    return ParserResult::Fail;
                }
                if self.get_current() != Tk::Bracket(Bracket::RBracket) {
                    return self.parser_error("right bracket");
                }
                self.advance();
                return ParserResult::Fail;
            }
            _ => {
                return self.parser_error("one of {integer, identifier, char, true, false, (}");
            }
        }
    }

    fn parser_error(&mut self, expected: &str) -> ParserResult {
        self.errors_counter += 1;
        let line_number = self.token_list[self.current_position].line_number;
        let character_number = self.token_list[self.current_position].character_number;
        let file_lines = self.read_lines(&self.file_name);

        eprint!(
            "\x1b[34m{}:{}:{}: \x1b[0m",
            self.file_name, line_number, character_number
        );
        eprintln!(
            "\x1b[91merror parser: \x1b[0mexpected `\x1b[34m{}\x1b[0m`, found `\x1b[34m{:?}\x1b[0m`",
            expected,
            self.get_current()
        );
        if self.errors_counter > 1 {
            eprintln!("(this error might be a propagation of the previous ones)");
        }
        if line_number as usize > file_lines.len() {
            return ParserResult::Fail;
        }

        eprintln!(
            "{}\t| {}",
            line_number,
            file_lines[line_number as usize - 1]
        );
        eprint!("\t| ");

        if character_number >= 4 {
            for _ in 0..character_number - 4 {
                eprint!(" ");
            }
        }

        for _ in 0..3.min(character_number - 1) {
            eprint!("\x1b[91m~\x1b[0m");
        }

        eprintln!("\x1b[91m^~~~\x1b[0m");

        return ParserResult::Fail;
    }

    fn read_lines(&self, filename: &str) -> Vec<String> {
        let mut result = Vec::new();

        for line in read_to_string(filename).unwrap().lines() {
            result.push(line.to_string())
        }

        result
    }
}
