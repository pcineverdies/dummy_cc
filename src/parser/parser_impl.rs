use crate::ast::ast_impl::{AstNode, AstNodeWrapper, SourceReference};
use crate::lexer::lexer_impl::{Bracket, Keyword, Operator, Tk, Token};
use crate::parser::resolution::Resolution;
use std::string::String;
use std::{fs::read_to_string, process::exit};

macro_rules! debug_println {
    ($($arg:tt)*) => (if ::std::cfg!(debug_assertions) { ::std::println!($($arg)*); })
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Parser {
    token_list: Vec<Token>,
    current_position: usize,
    depth: u32,
    errors_counter: u32,
    file_name: String,
    resolution: Resolution,
    skip_erorrs: bool,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserResult {
    Match(AstNodeWrapper),
    Unmatch,
    Fail,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserErrorType {
    ScopeError,
    TokenError,
}

use AstNode::*;
use Bracket::*;
use Keyword::*;
use Operator::*;
use ParserErrorType::*;
use ParserResult::*;
use Tk::*;

impl Parser {
    //! Parser::new
    //!
    //! Initiate the parser with a vector of tokens generated by the lexer
    //!
    //! @input token_list [Vec<Token>]: List of input tokens
    //! @input file_name [String]: Name of the file under analysis
    //! @return [Parser]: Generated parser
    pub fn new(token_list: Vec<Token>, file_name: String) -> Parser {
        Parser {
            token_list,
            current_position: 0,
            depth: 0,
            errors_counter: 0,
            file_name,
            resolution: Resolution::new(),
            skip_erorrs: false,
        }
    }

    /// Parser::get_current
    ///
    /// Get the current token under exam
    fn get_current(&self) -> Tk {
        return self.token_list[self.current_position].clone().tk;
    }

    /// Parser::get_current_token
    ///
    /// Get the full current token under exam
    fn get_current_token(&mut self) -> Token {
        return self.token_list[self.current_position].clone();
    }

    /// Parser::previous
    ///
    /// Go to previous token
    fn previous(&mut self) {
        self.current_position -= 1;
        debug_println!("Restoring {:?}", self.get_current());
    }

    /// Parser::advance
    ///
    /// Advance to next token
    fn advance(&mut self) {
        debug_println!("Consuming {:?}", self.get_current());
        self.current_position += 1;
        if self.current_position as usize >= self.token_list.len() {
            eprintln!(
                "\x1b[91mFailed parsing with {} errors\x1b[0m",
                self.errors_counter
            );
            exit(1);
        }
    }

    /// Parser::parse
    ///
    /// Parse the list of token provided to the parser during initialization
    ///
    /// @return [Option<AstNode>]: return the AST in case of success, None if an error occurred in the
    /// process
    pub fn parse(&mut self) -> Option<AstNodeWrapper> {
        debug_println!("-> parse");

        match self.external_declaration_list() {
            Match(node) => {
                if self.get_current() != Tk::EOF {
                    self.parser_error("EOF", TokenError);
                } else if self.errors_counter == 0 {
                    return Some(node);
                }
            }
            _ => {}
        }

        eprintln!(
            "\x1b[91mFailed parsing with {} errors\x1b[0m",
            self.errors_counter
        );
        return None;
    }

    /// Parser::external_declaration_list
    ///
    /// Parse an external_declaration_list, defined as
    ///
    /// External_declaration_list -> {Declaration}*
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn external_declaration_list(&mut self) -> ParserResult {
        debug_println!("-> external_declaration_list");
        let mut result: Vec<AstNodeWrapper> = Vec::new();
        let mut source_ref = SourceReference {
            ..Default::default()
        };
        while self.get_current() != Tk::EOF {
            match self.declaration() {
                Match(node) => {
                    source_ref = SourceReference::merge(&node.source_ref, &source_ref);
                    result.push(node)
                }
                _ => return Fail,
            }
        }
        return Match(AstNodeWrapper {
            node: AstNode::new_declaration_list(&result),
            source_ref,
            ..Default::default()
        });
    }

    /// Parser::declaration
    ///
    /// Parse a compound_statement, defined as
    ///
    /// Declaration ->  Pointer_type identifier stop
    ///              |  Pointer_type identifier =  Expression stop
    ///              |  Pointer_type identifier ( Parameter_list ) stop
    ///              |  Pointer_type identifier ( Parameter_list ) Compound_statement
    ///              |  Pointer_type identifier [ Expression ] stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn declaration(&mut self) -> ParserResult {
        debug_println!("-> declaration");
        match self.pointer_type() {
            Match(type_node) => match self.get_current() {
                Tk::Identifier(_) => {
                    let id_token = self.get_current_token();
                    self.advance();
                    match self.get_current() {
                        Tk::Semicolon => {
                            let token = self.get_current_token();
                            self.advance();
                            let source_ref = SourceReference::merge(
                                &type_node.source_ref,
                                &SourceReference::from_token(&token),
                            );
                            return Match(AstNodeWrapper {
                                node: AstNode::new_var_decl(
                                    &type_node,
                                    &id_token,
                                    &AstNodeWrapper {
                                        ..Default::default()
                                    },
                                ),
                                source_ref,
                                ..Default::default()
                            });
                        }
                        Tk::Operator(Assign) => {
                            self.advance();
                            match self.expression() {
                                Match(expr) => {
                                    if self.get_current() != Tk::Semicolon {
                                        return self.parser_error(";", TokenError);
                                    }
                                    let token = self.get_current_token();
                                    self.advance();
                                    let source_ref = SourceReference::merge(
                                        &type_node.source_ref,
                                        &SourceReference::from_token(&token),
                                    );
                                    return Match(AstNodeWrapper {
                                        node: AstNode::new_var_decl(&type_node, &id_token, &expr),
                                        source_ref,
                                        ..Default::default()
                                    });
                                }
                                _ => Fail,
                            }
                        }
                        Tk::Bracket(LBracket) => {
                            self.advance();
                            match self.parameter_list() {
                                Match(list) => {
                                    let (body, source_ref);
                                    if self.get_current() != Tk::Bracket(RBracket) {
                                        return self.parser_error(")", TokenError);
                                    }
                                    self.advance();
                                    if self.get_current() == Tk::Semicolon {
                                        source_ref = SourceReference::merge(
                                            &type_node.source_ref,
                                            &SourceReference::from_token(&self.get_current_token()),
                                        );
                                        self.advance();
                                        body = AstNodeWrapper {
                                            ..Default::default()
                                        };
                                    } else {
                                        match self.compound_statement() {
                                            Match(node) => {
                                                body = node;
                                                source_ref = SourceReference::merge(
                                                    &type_node.source_ref,
                                                    &body.source_ref,
                                                );
                                            }
                                            _ => return Fail,
                                        }
                                    }
                                    match list.node {
                                        AstNode::FuncDeclNode(_, _, params, _) => {
                                            return Match(AstNodeWrapper {
                                                node: AstNode::new_func_decl(
                                                    &type_node, &id_token, &params, &body,
                                                ),
                                                source_ref,
                                                ..Default::default()
                                            });
                                        }
                                        _ => return Fail,
                                    }
                                }
                                _ => Fail,
                            }
                        }
                        Tk::Bracket(LSquare) => {
                            self.advance();
                            match self.expression() {
                                Match(node) => {
                                    if self.get_current() != Tk::Bracket(RSquare) {
                                        return self.parser_error("]", TokenError);
                                    }
                                    self.advance();
                                    if self.get_current() != Tk::Semicolon {
                                        return self.parser_error(";", TokenError);
                                    }
                                    let token = self.get_current_token();
                                    let source_ref = SourceReference::merge(
                                        &type_node.source_ref,
                                        &SourceReference::from_token(&token),
                                    );
                                    self.advance();
                                    return Match(AstNodeWrapper {
                                        node: AstNode::new_array_decl(&type_node, &id_token, &node),
                                        source_ref,
                                        ..Default::default()
                                    });
                                }
                                _ => Fail,
                            }
                        }
                        _ => return self.parser_error("", TokenError),
                    }
                }
                _ => {
                    return self.parser_error("identifier", TokenError);
                }
            },
            _ => Fail,
        }
    }

    /// Parser::parameter_list
    ///
    /// Parse a parameter_list, defined as
    ///
    /// Parameter_list ->   {Pointer_type identifier {, Pointer_type identifier}* }
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn parameter_list(&mut self) -> ParserResult {
        debug_println!("-> parameter_list");

        let mut result: Vec<AstNodeWrapper> = Vec::new();
        if self.get_current() == Tk::Bracket(RBracket) {
            return Match(AstNodeWrapper {
                node: AstNode::new_func_decl(
                    &AstNodeWrapper {
                        ..Default::default()
                    },
                    &self.get_current_token(),
                    &result,
                    &AstNodeWrapper {
                        ..Default::default()
                    },
                ),
                ..Default::default()
            });
        }
        match self.pointer_type() {
            Match(type_node) => match self.get_current() {
                Identifier(_) => {
                    let token = self.get_current_token();
                    self.advance();
                    let source_ref = SourceReference::merge(
                        &SourceReference::from_token(&token),
                        &type_node.source_ref,
                    );
                    result.push(AstNodeWrapper {
                        node: AstNode::new_parameter(&token, &type_node),
                        source_ref,
                        ..Default::default()
                    });
                    while self.get_current() == Tk::Operator(Operator::Comma) {
                        self.advance();
                        match self.pointer_type() {
                            Match(type_node) => match self.get_current() {
                                Identifier(_) => {
                                    let token = self.get_current_token();
                                    self.advance();
                                    let source_ref = SourceReference::merge(
                                        &SourceReference::from_token(&token),
                                        &type_node.source_ref,
                                    );
                                    result.push(AstNodeWrapper {
                                        node: AstNode::new_parameter(&token, &type_node),
                                        source_ref,
                                        ..Default::default()
                                    });
                                }
                                _ => return Fail,
                            },
                            _ => return Fail,
                        }
                    }
                    if self.get_current() != Tk::Bracket(RBracket) {
                        return Fail;
                    }
                    return Match(AstNodeWrapper {
                        node: AstNode::new_func_decl(
                            &AstNodeWrapper {
                                ..Default::default()
                            },
                            &self.get_current_token(),
                            &result,
                            &AstNodeWrapper {
                                ..Default::default()
                            },
                        ),
                        ..Default::default()
                    });
                }
                _ => self.parser_error("identifier", TokenError),
            },
            _ => Fail,
        }
    }

    /// Parser::compound_statement
    ///
    /// Parse a compound_statement, defined as
    ///
    /// Compound_statement ->  { {statement}* }
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn compound_statement(&mut self) -> ParserResult {
        debug_println!("-> compound_statement");

        let mut result: Vec<AstNodeWrapper> = Vec::new();
        if self.get_current() != Tk::Bracket(LCurly) {
            return self.parser_error("{", TokenError);
        }
        let token_l = self.get_current_token();
        self.advance();
        while self.get_current() != Tk::Bracket(RCurly) {
            match self.statement() {
                Match(node) => {
                    if node.node != AstNode::NullNode {
                        result.push(node);
                    }
                }
                _ => {
                    while self.get_current() != Tk::Bracket(RCurly)
                        && self.get_current() != Tk::Semicolon
                    {
                        debug_println!("!! skipping token to due error");
                        self.advance();
                    }
                    if self.get_current() == Tk::Semicolon {
                        self.advance();
                    }
                }
            }
        }
        if self.get_current() != Tk::Bracket(RCurly) {
            return self.parser_error("}", TokenError);
        }
        let token_r = self.get_current_token();
        self.advance();
        let source_ref = SourceReference::merge(
            &SourceReference::from_token(&token_l),
            &SourceReference::from_token(&token_r),
        );
        return Match(AstNodeWrapper {
            node: AstNode::new_compound(&result),
            source_ref,
            ..Default::default()
        });
    }

    /// Parser::statement
    ///
    /// Parse a statement, defined as
    ///
    /// Statement ->    Expression_statement
    ///            |    Declaration
    ///            |    Compound_statement
    ///            |    Selection_statement
    ///            |    Iteration_statement
    ///            |    Jump_statement
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn statement(&mut self) -> ParserResult {
        debug_println!("-> statement");
        if self.get_current().is_type() || self.get_current() == Tk::Keyword(Const) {
            match self.declaration() {
                Match(node) => return Match(node),
                Fail => return Fail,
                Unmatch => {}
            }
        }

        match self.get_current() {
            Tk::Bracket(LCurly) => match self.compound_statement() {
                Match(node) => return Match(node),
                _ => return Fail,
            },
            Tk::Keyword(Keyword::If) => match self.selection_statement() {
                Match(node) => return Match(node),
                _ => return Fail,
            },
            Tk::Keyword(Break) | Tk::Keyword(Continue) | Tk::Keyword(Return) => {
                match self.jump_statement() {
                    Match(node) => return Match(node),
                    _ => return Fail,
                }
            }
            Tk::Keyword(While) | Tk::Keyword(For) => match self.iteration_statement() {
                Match(node) => return Match(node),
                _ => return Fail,
            },
            _ => {}
        }

        match self.expression_statement() {
            Match(node) => return Match(node),
            _ => return Fail,
        }
    }

    /// Parser::jump_statement
    /// Parse an jump_statement, defined as
    ///
    /// Jump_statement ->   return Optional_expression stop
    ///                 |   break stop
    ///                 |   continue stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn jump_statement(&mut self) -> ParserResult {
        debug_println!("-> jump_statement");
        let token = self.get_current_token();
        match self.get_current() {
            Tk::Keyword(Continue) | Tk::Keyword(Break) => {
                self.advance();
                if self.get_current() != Tk::Semicolon {
                    return self.parser_error(";", TokenError);
                }
                let semicolon = self.get_current_token();
                self.advance();
                let source_ref = SourceReference::merge(
                    &SourceReference::from_token(&token),
                    &SourceReference::from_token(&semicolon),
                );
                return Match(AstNodeWrapper {
                    node: AstNode::new_jump(
                        &token,
                        &AstNodeWrapper {
                            ..Default::default()
                        },
                    ),
                    source_ref,
                    ..Default::default()
                });
            }
            Tk::Keyword(Return) => {
                self.advance();
                match self.optional_expression() {
                    Match(expr) => {
                        if self.get_current() != Tk::Semicolon {
                            return self.parser_error(";", TokenError);
                        }
                        let semicolon = self.get_current_token();
                        self.advance();
                        let source_ref = SourceReference::merge(
                            &SourceReference::from_token(&token),
                            &SourceReference::from_token(&semicolon),
                        );
                        return Match(AstNodeWrapper {
                            node: AstNode::new_jump(&token, &expr),
                            source_ref,
                            ..Default::default()
                        });
                    }
                    _ => Fail,
                }
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::iteration_statement
    /// Parse an iteration statement, defined as
    ///
    /// Iteration_statement ->  while ( Expression ) Compound_statement
    ///                      |  for ( Optional_expression stop Optional_expression stop Optional_expression ) Compound_statement
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn iteration_statement(&mut self) -> ParserResult {
        debug_println!("-> iteration_statement");
        match self.get_current() {
            Tk::Keyword(For) => {
                let token = self.get_current_token();
                self.advance();
                if self.get_current() != Tk::Bracket(LBracket) {
                    return self.parser_error("(", TokenError);
                }
                self.advance();
                match self.optional_expression() {
                    Match(expr1) => {
                        if self.get_current() != Tk::Semicolon {
                            return self.parser_error(";", TokenError);
                        }
                        self.advance();
                        match self.optional_expression() {
                            Match(expr2) => {
                                if self.get_current() != Tk::Semicolon {
                                    return self.parser_error(";", TokenError);
                                }
                                self.advance();
                                match self.optional_expression() {
                                    Match(expr3) => {
                                        if self.get_current() != Tk::Bracket(RBracket) {
                                            return self.parser_error(")", TokenError);
                                        }
                                        self.advance();
                                        match self.compound_statement() {
                                            Match(body) => {
                                                let source_ref = SourceReference::merge(
                                                    &SourceReference::from_token(&token),
                                                    &body.source_ref,
                                                );
                                                return Match(AstNodeWrapper {
                                                    node: AstNode::new_for(
                                                        &expr1, &expr2, &expr3, &body,
                                                    ),
                                                    source_ref,
                                                    ..Default::default()
                                                });
                                            }
                                            _ => Fail,
                                        }
                                    }
                                    _ => Fail,
                                }
                            }
                            _ => Fail,
                        }
                    }
                    _ => Fail,
                }
            }
            Tk::Keyword(While) => {
                let token = self.get_current_token();
                self.advance();
                match self.get_current() {
                    Tk::Bracket(LBracket) => {
                        self.advance();
                        match self.expression() {
                            Match(expr) => match self.get_current() {
                                Tk::Bracket(RBracket) => {
                                    self.advance();
                                    match self.compound_statement() {
                                        Match(body) => {
                                            let source_ref = SourceReference::merge(
                                                &SourceReference::from_token(&token),
                                                &body.source_ref,
                                            );
                                            return Match(AstNodeWrapper {
                                                node: AstNode::new_while(&expr, &body),
                                                source_ref,
                                                ..Default::default()
                                            });
                                        }
                                        _ => Fail,
                                    }
                                }
                                _ => return self.parser_error(")", TokenError),
                            },
                            _ => Fail,
                        }
                    }
                    _ => return self.parser_error("(", TokenError),
                }
            }
            _ => {
                return self.parser_error("", TokenError);
            }
        }
    }

    /// Parser::selection_statement
    ///
    /// Parse a selection_statement, defined as
    ///
    /// Selection_statement ->  if ( Expression ) Compound_statement Else_statement
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn selection_statement(&mut self) -> ParserResult {
        debug_println!("-> selection_statement");
        match self.get_current() {
            Tk::Keyword(If) => {
                let token = self.get_current_token();
                self.advance();
                if self.get_current() != Tk::Bracket(LBracket) {
                    self.parser_error("(", TokenError);
                }
                self.advance();
                match self.expression() {
                    Match(expr) => {
                        if self.get_current() != Tk::Bracket(RBracket) {
                            self.parser_error(")", TokenError);
                        }
                        self.advance();
                        match self.compound_statement() {
                            Match(body) => match self.else_statement() {
                                Match(else_body) => {
                                    let source_ref = SourceReference::merge(
                                        &SourceReference::from_token(&token),
                                        &body.source_ref,
                                    );
                                    return Match(AstNodeWrapper {
                                        node: AstNode::new_if(&expr, &body, &else_body),
                                        source_ref,
                                        ..Default::default()
                                    });
                                }
                                _ => return Fail,
                            },
                            _ => return Fail,
                        }
                    }
                    _ => return Fail,
                }
            }
            _ => self.parser_error("if", TokenError),
        }
    }

    /// Parser::else_statement
    ///
    /// Parse an else_statement, defined as
    ///
    /// Else_statement ->   ε
    ///                 |   else Compound_statement
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn else_statement(&mut self) -> ParserResult {
        debug_println!("-> else_statement");
        if self.get_current() != Tk::Keyword(Else) {
            return Match(AstNodeWrapper {
                ..Default::default()
            });
        }
        let token = self.get_current_token();
        self.advance();
        match self.compound_statement() {
            Match(mut node) => {
                node.source_ref =
                    SourceReference::merge(&SourceReference::from_token(&token), &node.source_ref);
                Match(node)
            }
            _ => Fail,
        }
    }

    /// Parser::expression_statement
    ///
    /// Parse an expression_statement, defined as
    ///
    /// Expression_statement -> Optional_expression stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_statement(&mut self) -> ParserResult {
        debug_println!("-> expression_statement");
        match self.optional_expression() {
            Match(node) => {
                if self.get_current() == Tk::Semicolon {
                    let token = self.get_current_token();
                    self.advance();
                    if node.node == AstNode::NullNode {
                        return Match(node);
                    }
                    let source_ref = SourceReference::merge(
                        &SourceReference::from_token(&token),
                        &node.source_ref,
                    );
                    return Match(AstNodeWrapper {
                        node: AstNode::new_expr_statement(&node),
                        source_ref,
                        ..Default::default()
                    });
                }
                return self.parser_error(";", TokenError);
            }
            _ => return Fail,
        }
    }

    /// Parser::optional_expression
    ///
    /// Optional_expression ->  Expression
    ///                      |  ε
    ///
    /// Expression_statement -> Optional_expression stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn optional_expression(&mut self) -> ParserResult {
        debug_println!("-> optional_expression");
        match self.get_current() {
            Tk::Semicolon | Tk::Bracket(RBracket) => {
                return Match(AstNodeWrapper {
                    ..Default::default()
                });
            }
            _ => {}
        }

        match self.expression() {
            Match(node) => return Match(node),
            _ => return Fail,
        }
    }

    /// Parser::expression
    ///
    /// Parse an expression, defined as
    ///
    /// Expression ->    Logical_expression
    ///             |    Unary_expression = Expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression(&mut self) -> ParserResult {
        debug_println!("-> expression");

        let state_parser = self.clone();
        self.skip_erorrs = true;
        match self.unary_expression() {
            Match(node_unary) => {
                self.skip_erorrs = false;
                match self.get_current() {
                    Operator(Assign) => {
                        let token = self.get_current_token();
                        self.advance();
                        match self.expression() {
                            Match(node) => {
                                let source_ref = SourceReference::merge(
                                    &node_unary.source_ref,
                                    &node.source_ref,
                                );
                                return Match(AstNodeWrapper {
                                    node: AstNode::new_binary(&token, &node_unary, &node),
                                    source_ref,
                                    ..Default::default()
                                });
                            }
                            _ => return Fail,
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        debug_println!("~~ Backtracking ~~");
        *self = state_parser;
        match self.logical_expression() {
            Match(node) => return Match(node),
            _ => return Fail,
        }
    }

    /// Parser::logical_expression
    ///
    /// Parse a logical_expression, defined as
    ///
    /// Logical_expression ->   Equality_expression
    ///                     |   Equality_expression & Logical_expression
    ///                     |   Equality_expression | Logical_expression
    ///                     |   Equality_expression ^ Logical_expression
    ///                     |   Equality_expression and Logical_expression
    ///                     |   Equality_expression or Logical_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn logical_expression(&mut self) -> ParserResult {
        debug_println!("-> logical_expression");

        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        match self.equality_expression() {
            Match(node) => {
                node_stack.push(node);
                while self.get_current() == Tk::Operator(AndOp)
                    || self.get_current() == Tk::Operator(OrOp)
                    || self.get_current() == Tk::Operator(XorOp)
                    || self.get_current() == Tk::Keyword(And)
                    || self.get_current() == Tk::Keyword(Or)
                {
                    op_stack.push(self.get_current_token());
                    self.advance();
                    match self.equality_expression() {
                        Match(node) => node_stack.push(node),
                        _ => return Fail,
                    }
                }
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        ..Default::default()
                    };
                }

                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                {
                    return self.parser_error("", TokenError);
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::equality_expression
    ///
    /// Parse an equality_expression, defined as
    ///
    /// Equality_expression ->  Relational_expression
    ///                      |  Relational_expression == Equality_expression
    ///                      |  Relational_expression != Equality_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn equality_expression(&mut self) -> ParserResult {
        debug_println!("-> equality_expression");

        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        match self.relational_expression() {
            Match(node) => {
                node_stack.push(node);
                while self.get_current() == Tk::Operator(EqualCompare)
                    || self.get_current() == Tk::Operator(DiffCompare)
                {
                    op_stack.push(self.get_current_token());
                    self.advance();
                    match self.relational_expression() {
                        Match(node) => node_stack.push(node),
                        _ => return Fail,
                    }
                }
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        ..Default::default()
                    };
                }

                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                {
                    return self.parser_error("", TokenError);
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::relational_expression
    ///
    /// Parse a relational_expression, defined as
    ///
    /// Relational_expression ->    Shift_expression
    ///                        |    Shift_expression >= Relational_expression
    ///                        |    Shift_expression <= Relational_expression
    ///                        |    Shift_expression < Relational_expression
    ///                        |    Shift_expression > Relational_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn relational_expression(&mut self) -> ParserResult {
        debug_println!("-> relational_expression");

        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        match self.shift_expression() {
            Match(node) => {
                node_stack.push(node);
                while self.get_current() == Tk::Operator(LECompare)
                    || self.get_current() == Tk::Operator(GECompare)
                    || self.get_current() == Tk::Operator(LTCompare)
                    || self.get_current() == Tk::Operator(GTCompare)
                {
                    op_stack.push(self.get_current_token());
                    self.advance();
                    match self.shift_expression() {
                        Match(node) => node_stack.push(node),
                        _ => return Fail,
                    }
                }
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        ..Default::default()
                    };
                }

                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                    && self.get_current() != Tk::Operator(EqualCompare)
                    && self.get_current() != Tk::Operator(DiffCompare)
                {
                    return self.parser_error("", TokenError);
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::shift_expression
    ///
    /// Parse a shift_expression, defined as
    ///
    /// Shift_expression -> Additive_expression
    ///                   | Additive_expression << Shift_expression
    ///                   | Additive_expression >> Shift_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn shift_expression(&mut self) -> ParserResult {
        debug_println!("-> shift_expression");

        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        match self.additive_expression() {
            Match(node) => {
                node_stack.push(node);
                while self.get_current() == Tk::Operator(LShift)
                    || self.get_current() == Tk::Operator(RShift)
                {
                    op_stack.push(self.get_current_token());
                    self.advance();
                    match self.additive_expression() {
                        Match(node) => node_stack.push(node),
                        _ => return Fail,
                    }
                }
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        ..Default::default()
                    };
                }

                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                    && self.get_current() != Tk::Operator(EqualCompare)
                    && self.get_current() != Tk::Operator(DiffCompare)
                    && self.get_current() != Tk::Operator(LTCompare)
                    && self.get_current() != Tk::Operator(GTCompare)
                    && self.get_current() != Tk::Operator(LECompare)
                    && self.get_current() != Tk::Operator(GECompare)
                {
                    return self.parser_error("", TokenError);
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::additive_expression
    ///
    /// Parse a additive_expression, defined as
    ///
    /// Additive_expression ->  Multiplicative_expression
    ///                      |  Multiplicative_expression + Additive_expression
    ///                      |  Multiplicative_expression - Additive_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn additive_expression(&mut self) -> ParserResult {
        debug_println!("-> additive_expression");

        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        match self.multiplicative_expression() {
            Match(node) => {
                node_stack.push(node);
                while self.get_current() == Tk::Operator(Plus)
                    || self.get_current() == Tk::Operator(Minus)
                {
                    op_stack.push(self.get_current_token());
                    self.advance();
                    match self.multiplicative_expression() {
                        Match(node) => node_stack.push(node),
                        _ => return Fail,
                    }
                }
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        ..Default::default()
                    };
                }

                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                    && self.get_current() != Tk::Operator(EqualCompare)
                    && self.get_current() != Tk::Operator(DiffCompare)
                    && self.get_current() != Tk::Operator(LTCompare)
                    && self.get_current() != Tk::Operator(GTCompare)
                    && self.get_current() != Tk::Operator(LECompare)
                    && self.get_current() != Tk::Operator(GECompare)
                    && self.get_current() != Tk::Operator(LShift)
                    && self.get_current() != Tk::Operator(RShift)
                {
                    return self.parser_error("", TokenError);
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::multiplicative_expression
    ///
    /// Parse a multiplicative_expression, defined as
    ///
    /// Multiplicative_expression -> Cast_expression
    ///                            | Cast_expression * Multiplicative_expression
    ///                            | Cast_expression / Multiplicative_expression
    ///                            | Cast_expression % Multiplicative_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn multiplicative_expression(&mut self) -> ParserResult {
        debug_println!("-> multiplicative_expression");

        let mut op_stack: Vec<Token> = Vec::new();
        let mut node_stack: Vec<AstNodeWrapper> = Vec::new();

        match self.cast_expression() {
            Match(node) => {
                node_stack.push(node);
                while self.get_current() == Tk::Operator(Asterisk)
                    || self.get_current() == Tk::Operator(Slash)
                    || self.get_current() == Tk::Operator(Module)
                {
                    op_stack.push(self.get_current_token());
                    self.advance();
                    match self.cast_expression() {
                        Match(node) => node_stack.push(node),
                        _ => return Fail,
                    }
                }
                let mut result = node_stack.remove(0);
                let mut source_ref = result.source_ref.clone();
                while node_stack.len() != 0 {
                    let op = op_stack.remove(0);
                    let new_operand = node_stack.remove(0);
                    source_ref = SourceReference::merge(&source_ref, &new_operand.source_ref);
                    result = AstNodeWrapper {
                        node: AstNode::new_binary(&op, &result, &new_operand),
                        source_ref: source_ref.clone(),
                        ..Default::default()
                    };
                }

                if self.get_current() != Tk::Bracket(RBracket)
                    && self.get_current() != Tk::Semicolon
                    && self.get_current() != Tk::Bracket(RSquare)
                    && self.get_current() != Tk::Operator(Comma)
                    && self.get_current() != Tk::Operator(AndOp)
                    && self.get_current() != Tk::Operator(OrOp)
                    && self.get_current() != Tk::Operator(XorOp)
                    && self.get_current() != Tk::Keyword(And)
                    && self.get_current() != Tk::Keyword(Or)
                    && self.get_current() != Tk::Operator(EqualCompare)
                    && self.get_current() != Tk::Operator(DiffCompare)
                    && self.get_current() != Tk::Operator(LTCompare)
                    && self.get_current() != Tk::Operator(GTCompare)
                    && self.get_current() != Tk::Operator(LECompare)
                    && self.get_current() != Tk::Operator(GECompare)
                    && self.get_current() != Tk::Operator(LShift)
                    && self.get_current() != Tk::Operator(RShift)
                    && self.get_current() != Tk::Operator(Plus)
                    && self.get_current() != Tk::Operator(Minus)
                {
                    return self.parser_error("", TokenError);
                }
                Match(result)
            }
            _ => return Fail,
        }
    }

    /// Parser::cast_expression
    ///
    /// Parse a cast_expression, defined as
    ///
    /// Cast_expression ->  ( Pointer_type ) Cast_expression
    ///                  |  Unary_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn cast_expression(&mut self) -> ParserResult {
        debug_println!("-> cast_expression");
        match self.get_current() {
            Tk::Bracket(LBracket) => {
                let token_l = self.get_current_token();
                self.advance();
                if self.get_current().is_type() || self.get_current() == Tk::Keyword(Const) {
                    match self.pointer_type() {
                        Match(type_node) => match self.get_current() {
                            Tk::Bracket(RBracket) => {
                                self.advance();
                                match self.cast_expression() {
                                    Match(node) => {
                                        let source_ref = SourceReference::merge(
                                            &SourceReference::from_token(&token_l),
                                            &node.source_ref,
                                        );
                                        return Match(AstNodeWrapper {
                                            node: AstNode::new_cast(&type_node, &node),
                                            source_ref,
                                            ..Default::default()
                                        });
                                    }
                                    _ => return Fail,
                                }
                            }
                            _ => return self.parser_error(")", TokenError),
                        },
                        Unmatch => {
                            self.previous();
                        }
                        _ => return Fail,
                    }
                } else {
                    self.previous();
                }
            }
            _ => {}
        }
        match self.unary_expression() {
            Match(node) => Match(node),
            _ => Fail,
        }
    }

    /// Parser::pointer_type
    ///
    /// Parse a pointer_type, defined as
    ///
    /// Pointer_type -> {const} Type_native {*}*
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn pointer_type(&mut self) -> ParserResult {
        debug_println!("-> pointer_type");
        let mut pointer_counter = 0;
        let mut is_const = false;
        let mut source_ref = SourceReference::from_token(&self.get_current_token());
        if self.get_current() == Tk::Keyword(Const) {
            is_const = true;
            self.advance();
        }
        match self.type_native() {
            Match(node) => {
                while self.get_current() == Tk::Operator(Asterisk) {
                    pointer_counter += 1;
                    source_ref = SourceReference::merge(
                        &source_ref,
                        &SourceReference::from_token(&self.get_current_token()),
                    );
                    self.advance();
                }
                match self.get_current() {
                    Tk::Identifier(_) | Tk::Bracket(RBracket) => {}
                    _ => return self.parser_error("", TokenError),
                }
                match node.node {
                    AstNode::TypeNode(_, tt, _) => {
                        let new_node = AstNode::new_type(is_const, &tt, pointer_counter);
                        return Match(AstNodeWrapper {
                            node: new_node,
                            source_ref,
                            ..Default::default()
                        });
                    }
                    _ => return Fail,
                }
            }
            _ => Fail,
        }
    }

    /// Parser::type_native
    ///
    /// Parse a type_native, defined as
    ///
    /// Type_native -> u8 | u16 | u32 | i8 | i16 | i32 | void
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn type_native(&mut self) -> ParserResult {
        debug_println!("-> type_native");
        if self.get_current().is_type() {
            let token = self.get_current_token();
            let source_ref = SourceReference::from_token(&token);
            self.advance();
            return Match(AstNodeWrapper {
                node: AstNode::new_type(false, &token, 0),
                source_ref,
                ..Default::default()
            });
        } else {
            return self.parser_error("type", TokenError);
        }
    }

    /// Parser::unary_expression
    ///
    /// Parse a unary_expression, defined as
    ///
    /// Unary_expression -> Postfix_expression
    ///                   | + Unary_expression
    ///                   | - Unary_expression
    ///                   | ! Unary_expression
    ///                   | & Unary_expression
    ///                   | * Unary_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn unary_expression(&mut self) -> ParserResult {
        debug_println!("-> unary_expression");
        match self.get_current() {
            Tk::Operator(Plus)
            | Tk::Operator(Minus)
            | Tk::Operator(Complement)
            | Tk::Operator(AndOp)
            | Tk::Operator(Asterisk) => {
                let token = self.get_current_token();
                self.advance();
                match self.unary_expression() {
                    Match(node) => {
                        let source_ref = SourceReference::merge(
                            &SourceReference::from_token(&token),
                            &node.source_ref,
                        );
                        return Match(AstNodeWrapper {
                            node: AstNode::new_prefix(&token, &node),
                            source_ref,
                            ..Default::default()
                        });
                    }
                    _ => return Fail,
                }
            }
            _ => match self.postfix_expression() {
                Match(node) => Match(node),
                _ => Fail,
            },
        }
    }

    /// Parser::postfix_expression
    ///
    /// Parse a postfix_expression, defined as
    ///
    /// Postfix_expression ->   Primary_expression  Postfix_operator
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn postfix_expression(&mut self) -> ParserResult {
        debug_println!("-> postfix_expression");
        match self.primary_expression() {
            Match(mut node) => {
                while self.get_current() == Tk::Bracket(LSquare)
                    || self.get_current() == Tk::Bracket(LBracket)
                {
                    match self.postfix_operator() {
                        Match(node_operator) => {
                            let source_ref =
                                SourceReference::merge(&node.source_ref, &node_operator.source_ref);
                            match node_operator.node {
                                SelectorNode(_, op) => {
                                    node = AstNodeWrapper {
                                        node: AstNode::new_selector(&node, &op),
                                        source_ref,
                                        ..Default::default()
                                    };
                                }
                                ProcedureNode(_, op) => {
                                    node = AstNodeWrapper {
                                        node: AstNode::new_procedure(&node, &op),
                                        source_ref,
                                        ..Default::default()
                                    };
                                }
                                _ => return Fail,
                            }
                        }
                        Fail => return Fail,
                        Unmatch => break,
                    }
                }
                return Match(node);
            }
            _ => return Fail,
        }
    }

    /// Parser::postfix_operator
    ///
    /// Parse a postfix_operator, defined as
    ///
    /// Postfix_operator -> [ Expression ] Postfix_operator
    ///                   | ( ) Postfix_operator
    ///                   | ( Expression_list ) Postfix_operator
    ///                   | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn postfix_operator(&mut self) -> ParserResult {
        debug_println!("-> postfix_operator");
        match self.get_current() {
            Tk::Bracket(LSquare) => {
                let token_l = self.get_current_token();
                self.advance();
                match self.expression() {
                    Match(mut node) => match self.get_current() {
                        Tk::Bracket(RSquare) => {
                            let token_r = self.get_current_token();
                            let source_ref = SourceReference::merge(
                                &SourceReference::from_token(&token_l),
                                &SourceReference::from_token(&token_r),
                            );
                            node.source_ref = source_ref.clone();
                            self.advance();
                            let new_node = AstNode::new_selector(
                                &AstNodeWrapper {
                                    ..Default::default()
                                },
                                &node,
                            );
                            return Match(AstNodeWrapper {
                                node: new_node,
                                source_ref,
                                ..Default::default()
                            });
                        }
                        _ => return self.parser_error("]", TokenError),
                    },
                    _ => Fail,
                }
            }
            Tk::Bracket(LBracket) => {
                let token_l = self.get_current_token();
                self.advance();
                match self.get_current() {
                    Tk::Bracket(RBracket) => {
                        let token_r = self.get_current_token();
                        let source_ref = SourceReference::merge(
                            &SourceReference::from_token(&token_l),
                            &SourceReference::from_token(&token_r),
                        );
                        self.advance();
                        let new_node = AstNode::new_procedure(
                            &AstNodeWrapper {
                                ..Default::default()
                            },
                            &Vec::new(),
                        );
                        return Match(AstNodeWrapper {
                            node: new_node,
                            source_ref,
                            ..Default::default()
                        });
                    }
                    _ => {}
                }
                match self.expression_list() {
                    Match(node) => return Match(node),
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare)
            | Tk::Operator(LShift)
            | Tk::Operator(RShift)
            | Tk::Operator(Asterisk)
            | Tk::Operator(Slash)
            | Tk::Operator(Module)
            | Tk::Operator(Assign)
            | Tk::Operator(Plus)
            | Tk::Operator(Minus) => return Unmatch,
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::primary_expression
    ///
    /// Parse a primary_expression, defined as
    ///
    /// Primary_expression ->   identifier
    ///                     |   number
    ///                     |   char
    ///                     |   ( Expression )
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn primary_expression(&mut self) -> ParserResult {
        debug_println!("-> primary_expression");
        match self.get_current() {
            Tk::Identifier(_) | Tk::IntegerLiteral(_) | Tk::Char(_) => {
                let token = self.get_current_token();
                let source_ref = SourceReference::from_token(&token);
                let node = AstNode::new_primary(&token);
                let result = Match(AstNodeWrapper {
                    node,
                    source_ref,
                    ..Default::default()
                });
                self.advance();
                return result;
            }
            Tk::Bracket(LBracket) => {
                let token_l = self.get_current_token();
                self.advance();
                match self.expression() {
                    Match(mut node) => match self.get_current() {
                        Tk::Bracket(RBracket) => {
                            let token_r = self.get_current_token();
                            let source_ref = SourceReference::merge(
                                &SourceReference::from_token(&token_l),
                                &SourceReference::from_token(&token_r),
                            );
                            node.source_ref = source_ref;
                            self.advance();
                            return Match(node);
                        }
                        _ => return self.parser_error(")", TokenError),
                    },
                    _ => return Fail,
                }
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::expression_list
    ///
    /// Parse a expression_list, defined as
    ///
    /// Expression_list ->  Expression Expression_list | Expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_list(&mut self) -> ParserResult {
        debug_println!("-> expression_list");
        let mut list: Vec<AstNodeWrapper> = Vec::new();
        let mut source_ref: SourceReference;
        match self.expression() {
            Match(node) => {
                source_ref = node.source_ref.clone();
                list.push(node);
                while self.get_current() == Tk::Operator(Comma) {
                    self.advance();
                    match self.expression() {
                        Match(node) => {
                            list.push(node.clone());
                            source_ref.last_char = node.source_ref.last_char;
                            source_ref.last_line = node.source_ref.last_line;
                        }
                        _ => return Fail,
                    }
                }
                if self.get_current() == Tk::Bracket(RBracket) {
                    self.advance();
                    let node = AstNode::new_procedure(
                        &AstNodeWrapper {
                            ..Default::default()
                        },
                        &list,
                    );
                    return Match(AstNodeWrapper {
                        node,
                        source_ref,
                        ..Default::default()
                    });
                }
                return self.parser_error(")", TokenError);
            }
            _ => return Fail,
        }
    }

    /// Parser::parser_error
    ///
    /// Generate an error from the parser
    ///
    /// @in expected [&str]: string to give some information about the error
    /// @in error [ParserErrorType]: type of error to handle
    /// @return [ParseResult]: Always Fail
    fn parser_error(&mut self, expected: &str, error: ParserErrorType) -> ParserResult {
        if self.skip_erorrs {
            return Fail;
        }
        self.errors_counter += 1;
        let line_number = self.token_list[self.current_position].line_number;
        let last_character = self.token_list[self.current_position].last_character;
        let first_character = self.token_list[self.current_position].first_character;
        let file_lines = self.read_lines(&self.file_name);

        eprint!(
            "\x1b[34m{}:{}:{}: \x1b[0m",
            self.file_name, line_number, first_character
        );

        match error {
            TokenError => {
                if expected.len() != 0 {
                    eprintln!(
                        "\x1b[91merror parser: \x1b[0mexpected `\x1b[34m{}\x1b[0m`, found `\x1b[34m{}\x1b[0m`",
                        expected,
                        self.get_current()
                    );
                } else {
                    eprintln!(
                        "\x1b[91merror parser: \x1b[0munexpected token `\x1b[34m{}\x1b[0m`",
                        self.get_current()
                    );
                }
            }
            _ => {}
        }
        if line_number as usize > file_lines.len() {
            return Fail;
        }

        eprint!(
            "{}\t| {}\n\t| ",
            line_number,
            file_lines[line_number as usize - 1]
        );

        for i in 0..last_character {
            if i < first_character - 1 {
                eprint!(" ");
            } else if i == first_character - 1 {
                eprint!("\x1b[91m^\x1b[0m");
            } else {
                eprint!("\x1b[91m~\x1b[0m");
            }
        }
        eprintln!("");

        return Fail;
    }

    /// Parser::read_lines
    ///
    /// Get all the linest from a required source file
    ///
    /// @in expected [&str]: file name
    /// @return [Vec<String>]: vector of all the strings in the file
    fn read_lines(&self, filename: &str) -> Vec<String> {
        let mut result = Vec::new();

        for line in read_to_string(filename).unwrap().lines() {
            result.push(line.to_string())
        }

        result
    }
}
