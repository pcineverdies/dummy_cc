use crate::lexer::lexer_impl::{Bracket, Keyword, Operator, Tk, Token};
use crate::parser::resolution::Resolution;
use std::string::String;
use std::{fs::read_to_string, process::exit};

macro_rules! debug_println {
    ($($arg:tt)*) => (if ::std::cfg!(debug_assertions) { ::std::println!($($arg)*); })
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Parser {
    token_list: Vec<Token>,
    current_position: usize,
    depth: u32,
    errors_counter: u32,
    file_name: String,
    resolution: Resolution,
    skip_erorrs: bool,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserResult {
    Match,
    Unmatch,
    Fail,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum ParserErrorType {
    ScopeError,
    TokenError,
}

use Bracket::*;
use Keyword::*;
use Operator::*;
use ParserErrorType::*;
use ParserResult::*;
use Tk::*;

impl Parser {
    //! Parser::new
    //!
    //! Initiate the parser with a vector of tokens generated by the lexer
    //!
    //! @input token_list [Vec<Token>]: List of input tokens
    //! @input file_name [String]: Name of the file under analysis
    //! @return [Parser]: Generated parser
    pub fn new(token_list: Vec<Token>, file_name: String) -> Parser {
        Parser {
            token_list,
            current_position: 0,
            depth: 0,
            errors_counter: 0,
            file_name,
            resolution: Resolution::new(),
            skip_erorrs: false,
        }
    }

    /// Parser::get_current
    ///
    /// Get the current token under exam
    fn get_current(&self) -> Tk {
        return self.token_list[self.current_position].clone().tk;
    }

    /// Parser::get_current_token
    ///
    /// Get the full current token under exam
    fn get_current_token(&mut self) -> Token {
        return self.token_list[self.current_position].clone();
    }

    /// Parser::previous
    ///
    /// Go to previous token
    fn previous(&mut self) {
        self.current_position -= 1;
        debug_println!("Restoring {:?}", self.get_current());
    }

    /// Parser::advance
    ///
    /// Advance to next token
    fn advance(&mut self) {
        debug_println!("Consuming {:?}", self.get_current());
        self.current_position += 1;
        if self.current_position as usize >= self.token_list.len() {
            eprintln!(
                "\x1b[91mFailed parsing with {} errors\x1b[0m",
                self.errors_counter
            );
            exit(1);
        }
    }

    /// Parser::parse
    ///
    /// Parse the list of token provided to the parser during initialization
    ///
    /// @return [Option<()>]: return the AST in case of success, None if an error occurred in the
    /// process
    pub fn parse(&mut self) -> Option<()> {
        debug_println!("-> parse");

        match self.external_declaration_list() {
            Match => {
                if self.get_current() != Tk::EOF {
                    self.parser_error("EOF", TokenError);
                    return None;
                } else if self.errors_counter > 0 {
                    return None;
                } else {
                    return Some(());
                }
            }
            _ => {
                return None;
            }
        }
    }

    /// Parser::external_declaration_list
    ///
    /// Parse an external_declaration_list, defined as
    ///
    /// External_declaration_list -> Declaration External_declaration_list_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn external_declaration_list(&mut self) -> ParserResult {
        debug_println!("-> external_declaration_list");
        match self.declaration() {
            Match => match self.external_declaration_list_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::external_declaration_list_star
    ///
    /// Parse an external_declaration_list_star, defined as
    ///
    /// External_declaration_list_star ->   ε
    ///                                 |   External_declaration_list
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn external_declaration_list_star(&mut self) -> ParserResult {
        debug_println!("-> external_declaration_list_star");
        if self.get_current() == Tk::EOF {
            return Unmatch;
        }
        match self.external_declaration_list() {
            Match => Match,
            _ => Fail,
        }
    }

    /// Parser::declaration
    ///
    /// Parse a compound_statement, defined as
    ///
    /// Declaration ->  Type_declaration identifier stop
    ///              |  Type_declaration identifier =  Expression stop
    ///              |  Type_declaration identifier ( Parameter_list ) stop
    ///              |  Type_declaration identifier ( Parameter_list ) Compound_statement
    ///              |  Type_declaration identifier Array_declaration stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn declaration(&mut self) -> ParserResult {
        match self.type_declaration() {
            Match => match self.get_current() {
                Tk::Identifier(_) => {
                    self.advance();
                    match self.get_current() {
                        Tk::Semicolon => {
                            self.advance();
                            return Match;
                        }
                        Tk::Operator(Assign) => {
                            self.advance();
                            match self.expression() {
                                Match => {
                                    if self.get_current() != Tk::Semicolon {
                                        return self.parser_error(";", TokenError);
                                    }
                                    self.advance();
                                    return Match;
                                }
                                _ => Fail,
                            }
                        }
                        Tk::Bracket(LBracket) => {
                            self.advance();
                            match self.parameter_list() {
                                Match => {
                                    if self.get_current() != Tk::Bracket(RBracket) {
                                        return self.parser_error(")", TokenError);
                                    }
                                    self.advance();
                                    if self.get_current() == Tk::Semicolon {
                                        self.advance();
                                        return Match;
                                    }
                                    match self.compound_statement() {
                                        Match => Match,
                                        _ => Fail,
                                    }
                                }
                                _ => Fail,
                            }
                        }
                        Tk::Bracket(LSquare) => match self.array_declaration() {
                            Match => {
                                if self.get_current() != Tk::Semicolon {
                                    return self.parser_error(";", TokenError);
                                }
                                self.advance();
                                return Match;
                            }
                            _ => Fail,
                        },
                        _ => return self.parser_error("", TokenError),
                    }
                }
                _ => {
                    return self.parser_error("identifier", TokenError);
                }
            },
            _ => Fail,
        }
    }

    /// Parser::array_declaration
    ///
    /// Parse an array_declaration, defined as
    ///
    /// Array_declaration ->    [ Logical_expression ] | [Logical_expression] Array_declaration
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn array_declaration(&mut self) -> ParserResult {
        if self.get_current() != Tk::Bracket(LSquare) {
            return self.parser_error("[", TokenError);
        }
        self.advance();
        match self.logical_expression() {
            Match => {
                if self.get_current() != Tk::Bracket(RSquare) {
                    return self.parser_error("]", TokenError);
                }
                self.advance();
                if self.get_current() != Tk::Bracket(LSquare) {
                    return Match;
                }
                match self.array_declaration() {
                    Match => Match,
                    _ => Fail,
                }
            }
            _ => Fail,
        }
    }

    /// Parser::type_declaration
    ///
    /// Parse a type_declaration, defined as
    ///
    /// Type_declaration -> cost Pointer_type | Pointer_type
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn type_declaration(&mut self) -> ParserResult {
        debug_println!("-> type_declaration");
        if self.get_current() == Tk::Keyword(Const) {
            self.advance();
        }
        match self.pointer_type() {
            Match => Match,
            _ => Fail,
        }
    }

    /// Parser::parameter_list
    ///
    /// Parse a parameter_list, defined as
    ///
    /// Parameter_list ->   Type_declaration identifier Parameter_list_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn parameter_list(&mut self) -> ParserResult {
        debug_println!("-> parameter_list");
        if self.get_current() == Tk::Bracket(RBracket) {
            return Match;
        }
        match self.type_declaration() {
            Match => match self.get_current() {
                Identifier(_) => {
                    self.advance();
                    match self.parameter_list_star() {
                        Fail => Fail,
                        _ => Match,
                    }
                }
                _ => self.parser_error("identifier", TokenError),
            },
            _ => Fail,
        }
    }

    /// Parser::parameter_list_star
    ///
    /// Parse a parameter_list_star, defined as
    ///
    /// Parameter_list_star ->  , Parameter_list
    ///                      |  ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn parameter_list_star(&mut self) -> ParserResult {
        debug_println!("-> parameter_list_star");
        if self.get_current() == Tk::Bracket(RBracket) {
            return Unmatch;
        }
        match self.get_current() {
            Tk::Operator(Comma) => {
                self.advance();
                match self.parameter_list() {
                    Match => Match,
                    _ => Fail,
                }
            }
            _ => self.parser_error(",", TokenError),
        }
    }

    /// Parser::compound_statement
    ///
    /// Parse a compound_statement, defined as
    ///
    /// Compound_statement ->  { Statement_list }
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn compound_statement(&mut self) -> ParserResult {
        debug_println!("-> compound_statement");
        match self.get_current() {
            Tk::Bracket(LCurly) => {
                self.advance();
                match self.statement_list() {
                    Fail => return Fail,
                    _ => match self.get_current() {
                        Tk::Bracket(RCurly) => {
                            self.advance();
                            return Match;
                        }
                        _ => return self.parser_error("}", TokenError),
                    },
                }
            }
            _ => return self.parser_error("{", TokenError),
        }
    }

    /// Parser::statement_list
    ///
    /// Parse a statement_list, defined as
    ///
    /// Statement_list -> Statement Statement_list
    ///                 | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn statement_list(&mut self) -> ParserResult {
        debug_println!("-> statement_list");
        match self.get_current() {
            Tk::Bracket(RCurly) => {
                return Unmatch;
            }
            _ => {}
        }
        match self.statement() {
            Match => match self.statement_list() {
                Match => return Match,
                Unmatch => return Match,
                Fail => return Fail,
            },
            _ => return Fail,
        }
    }

    /// Parser::statement
    ///
    /// Parse a statement, defined as
    ///
    /// Statement ->    Expression_statement
    ///            |    Declaration
    ///            |    Compound_statement
    ///            |    Selection_statement
    ///            |    Iteration_statement
    ///            |    Jump_statement
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn statement(&mut self) -> ParserResult {
        debug_println!("-> statement");
        if self.get_current().is_type() || self.get_current() == Tk::Keyword(Const) {
            match self.declaration() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => {}
            }
        }

        match self.get_current() {
            Tk::Bracket(LCurly) => match self.compound_statement() {
                Match => return Match,
                _ => return Fail,
            },
            Tk::Keyword(Keyword::If) => match self.selection_statement() {
                Match => return Match,
                _ => return Fail,
            },
            Tk::Keyword(Break) | Tk::Keyword(Continue) | Tk::Keyword(Return) => {
                match self.jump_statement() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Keyword(While) | Tk::Keyword(For) => match self.iteration_statement() {
                Match => return Match,
                _ => return Fail,
            },
            _ => {}
        }

        match self.expression_statement() {
            Match => return Match,
            _ => return Fail,
        }
    }

    /// Parser::jump_statement
    /// Parse an jump_statement, defined as
    ///
    /// Jump_statement ->   return Optional_expression stop
    ///                 |   break stop
    ///                 |   continue stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn jump_statement(&mut self) -> ParserResult {
        debug_println!("-> jump_statement");
        match self.get_current() {
            Tk::Keyword(Continue) | Tk::Keyword(Break) => {
                self.advance();
                if self.get_current() != Tk::Semicolon {
                    return self.parser_error(";", TokenError);
                }
                self.advance();
                return Match;
            }
            Tk::Keyword(Return) => {
                self.advance();
                match self.optional_expression() {
                    Fail => Fail,
                    _ => {
                        if self.get_current() != Tk::Semicolon {
                            return self.parser_error(";", TokenError);
                        }
                        self.advance();
                        return Match;
                    }
                }
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::iteration_statement
    /// Parse an iteration statement, defined as
    ///
    /// Iteration_statement ->  while ( Expression ) Compound_statement
    ///                      |  for ( Optional_expression stop Optional_expression stop Optional_expression ) Compound_statement
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn iteration_statement(&mut self) -> ParserResult {
        debug_println!("-> iteration_statement");
        match self.get_current() {
            Tk::Keyword(For) => {
                self.advance();
                if self.get_current() != Tk::Bracket(LBracket) {
                    return self.parser_error("(", TokenError);
                }
                self.advance();
                match self.optional_expression() {
                    Match | Unmatch => {
                        if self.get_current() != Tk::Semicolon {
                            return self.parser_error(";", TokenError);
                        }
                        self.advance();
                        match self.optional_expression() {
                            Match | Unmatch => {
                                if self.get_current() != Tk::Semicolon {
                                    return self.parser_error(";", TokenError);
                                }
                                self.advance();
                                match self.optional_expression() {
                                    Match | Unmatch => {
                                        if self.get_current() != Tk::Bracket(RBracket) {
                                            return self.parser_error(")", TokenError);
                                        }
                                        self.advance();
                                        match self.compound_statement() {
                                            Match => Match,
                                            _ => Fail,
                                        }
                                    }
                                    _ => Fail,
                                }
                            }
                            _ => Fail,
                        }
                    }
                    _ => Fail,
                }
            }
            Tk::Keyword(While) => {
                self.advance();
                match self.get_current() {
                    Tk::Bracket(LBracket) => {
                        self.advance();
                        match self.expression() {
                            Match => match self.get_current() {
                                Tk::Bracket(RBracket) => {
                                    self.advance();
                                    match self.compound_statement() {
                                        Match => Match,
                                        _ => Fail,
                                    }
                                }
                                _ => return self.parser_error(")", TokenError),
                            },
                            _ => Fail,
                        }
                    }
                    _ => return self.parser_error("(", TokenError),
                }
            }
            _ => {
                return self.parser_error("", TokenError);
            }
        }
    }

    /// Parser::selection_statement
    ///
    /// Parse a selection_statement, defined as
    ///
    /// Selection_statement ->  if ( Expression ) Compound_statement Else_statement
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn selection_statement(&mut self) -> ParserResult {
        debug_println!("-> selection_statement");
        match self.get_current() {
            Tk::Keyword(If) => {
                self.advance();
                if self.get_current() != Tk::Bracket(LBracket) {
                    self.parser_error("(", TokenError);
                }
                self.advance();
                match self.expression() {
                    Match => {
                        if self.get_current() != Tk::Bracket(RBracket) {
                            self.parser_error(")", TokenError);
                        }
                        self.advance();
                        match self.compound_statement() {
                            Match => match self.else_statement() {
                                Fail => return Fail,
                                _ => return Match,
                            },
                            _ => return Fail,
                        }
                    }
                    _ => return Fail,
                }
            }
            _ => self.parser_error("if", TokenError),
        }
    }

    /// Parser::else_statement
    ///
    /// Parse an else_statement, defined as
    ///
    /// Else_statement ->   ε
    ///                 |   else Compound_statement
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn else_statement(&mut self) -> ParserResult {
        debug_println!("-> else_statement");
        if self.get_current() != Tk::Keyword(Else) {
            return Unmatch;
        }
        self.advance();
        match self.compound_statement() {
            Match => Match,
            _ => Fail,
        }
    }

    /// Parser::expression_statement
    ///
    /// Parse an expression_statement, defined as
    ///
    /// Expression_statement -> Optional_expression stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_statement(&mut self) -> ParserResult {
        debug_println!("-> expression_statement");
        match self.optional_expression() {
            Fail => return Fail,
            _ => {
                if self.get_current() == Tk::Semicolon {
                    self.advance();
                    return Match;
                }
                return self.parser_error(";", TokenError);
            }
        }
    }

    /// Parser::optional_expression
    ///
    /// Optional_expression ->  Expression
    ///                      |  ε
    ///
    /// Expression_statement -> Optional_expression stop
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn optional_expression(&mut self) -> ParserResult {
        debug_println!("-> optional_expression");
        match self.get_current() {
            Tk::Semicolon | Tk::Bracket(RBracket) => {
                return Unmatch;
            }
            _ => {}
        }

        match self.expression() {
            Match => return Match,
            _ => return Fail,
        }
    }

    /// Parser::expression
    ///
    /// Parse an expression, defined as
    ///
    /// Expression ->    Logical_expression
    ///             |    Unary_expression = Expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression(&mut self) -> ParserResult {
        debug_println!("-> expression");

        let state_parser = self.clone();
        self.skip_erorrs = true;
        match self.unary_expression() {
            Match => {
                self.skip_erorrs = false;
                match self.get_current() {
                    Operator(Assign) => {
                        self.advance();
                        match self.expression() {
                            Match => return Match,
                            _ => return Fail,
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        debug_println!("~~ Backtracking ~~");
        *self = state_parser;
        match self.logical_expression() {
            Match => return Match,
            _ => return Fail,
        }
    }

    /// Parser::logical_expression
    ///
    /// Parse a logical_expression, defined as
    ///
    /// Logical_expression ->   Equality_expression Logical_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn logical_expression(&mut self) -> ParserResult {
        debug_println!("-> logical_expression");
        match self.equality_expression() {
            Match => match self.logical_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::logical_expression_star
    ///
    /// Parse a logical_expression_star, defined as
    ///
    ///
    /// Logical_expression_star -> & Logical_expression
    ///                          | | Logical_expression
    ///                          | ^ Logical_expression
    ///                          | and Logical_expression
    ///                          | or Logical_expression
    ///                          | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn logical_expression_star(&mut self) -> ParserResult {
        debug_println!("-> logical_expression_star");
        match self.get_current() {
            Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or) => {
                self.advance();
                match self.logical_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket) | Tk::Semicolon | Tk::Bracket(RSquare) | Tk::Operator(Comma) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::equality_expression
    ///
    /// Parse an equality_expression, defined as
    ///
    /// Equality_expression ->   Relational_expression Equality_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn equality_expression(&mut self) -> ParserResult {
        debug_println!("-> equality_expression");
        match self.relational_expression() {
            Match => match self.equality_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::equality_expression_star
    ///
    /// Parse a equality_expression_star, defined as
    ///
    /// Equality_expression_star -> == Equality_expression
    ///                           | != Equality_expression
    ///                           | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn equality_expression_star(&mut self) -> ParserResult {
        debug_println!("-> equality_expression_star");
        match self.get_current() {
            Tk::Operator(EqualCompare) | Tk::Operator(DiffCompare) => {
                self.advance();
                match self.equality_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::relational_expression
    ///
    /// Parse a relational_expression, defined as
    ///
    /// Relational_expression ->    Shift_expression Relational_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn relational_expression(&mut self) -> ParserResult {
        debug_println!("-> relational_expression");
        match self.shift_expression() {
            Match => match self.relational_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::relational_expression_star
    ///
    /// Parse a relational_expression_star, defined as
    ///
    /// Relational_expression_star ->   > Relational_expression
    ///                             |   < Relational_expression
    ///                             |   >= Relational_expression
    ///                             |   <= Relational_expression
    ///                             |   ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn relational_expression_star(&mut self) -> ParserResult {
        debug_println!("-> relational_expression_star");
        match self.get_current() {
            Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare) => {
                self.advance();
                match self.relational_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::shift_expression
    ///
    /// Parse a shift_expression, defined as
    ///
    /// Shift_expression -> Additive_expression Shift_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn shift_expression(&mut self) -> ParserResult {
        debug_println!("-> shift_expression");
        match self.additive_expression() {
            Match => match self.shift_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::shift_expression_star
    ///
    /// Parse a shift_expression_star, defined as
    ///
    /// Shift_expression_star ->    << Shift_expression
    ///                        |    >> Shift_expression
    ///                        |    ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn shift_expression_star(&mut self) -> ParserResult {
        debug_println!("-> shift_expression_star");
        match self.get_current() {
            Tk::Operator(LShift) | Tk::Operator(RShift) => {
                self.advance();
                match self.shift_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::additive_expression
    ///
    /// Parse a additive_expression, defined as
    ///
    /// Additive_expression -> Multiplicative_expression Additive_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn additive_expression(&mut self) -> ParserResult {
        debug_println!("-> additive_expression");
        match self.multiplicative_expression() {
            Match => match self.additive_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::additive_expression_star
    ///
    /// Parse a additive_expression_star, defined as
    ///
    /// Additive_expression_star -> + Additive_expression
    ///                           | - Additive_expression
    ///                           | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn additive_expression_star(&mut self) -> ParserResult {
        debug_println!("-> additive_expression_star");
        match self.get_current() {
            Tk::Operator(Plus) | Tk::Operator(Minus) => {
                self.advance();
                match self.additive_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare)
            | Tk::Operator(LShift)
            | Tk::Operator(RShift) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::multiplicative_expression
    ///
    /// Parse a multiplicative_expression, defined as
    ///
    /// Multiplicative_expression -> Cast_expression Multiplicative_expression_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn multiplicative_expression(&mut self) -> ParserResult {
        debug_println!("-> multiplicative_expression");
        match self.cast_expression() {
            Match => match self.multiplicative_expression_star() {
                Match => return Match,
                Fail => return Fail,
                Unmatch => return Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::multiplicative_expression_star
    ///
    /// Parse a multiplicative_expression_star, defined as
    ///
    /// Multiplicative_expression_star ->   * Multiplicative_expression
    ///                                 |   / Multiplicative_expression
    ///                                 |   % Multiplicative_expression
    ///                                 |   ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn multiplicative_expression_star(&mut self) -> ParserResult {
        debug_println!("-> multiplicative_expression_star");
        match self.get_current() {
            Tk::Operator(Asterisk) | Tk::Operator(Slash) | Tk::Operator(Module) => {
                self.advance();
                match self.multiplicative_expression() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare)
            | Tk::Operator(LShift)
            | Tk::Operator(RShift)
            | Tk::Operator(Plus)
            | Tk::Operator(Minus) => {
                return Unmatch;
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::cast_expression
    ///
    /// Parse a cast_expression, defined as
    ///
    /// Cast_expression ->  ( Pointer_type ) Cast_expression
    ///                  |  Unary_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn cast_expression(&mut self) -> ParserResult {
        debug_println!("-> cast_expression");
        match self.get_current() {
            Tk::Bracket(LBracket) => {
                self.advance();
                if self.get_current().is_type() {
                    match self.pointer_type() {
                        Match => match self.get_current() {
                            Tk::Bracket(RBracket) => {
                                self.advance();
                                match self.cast_expression() {
                                    Match => return Match,
                                    _ => return Fail,
                                }
                            }
                            _ => return self.parser_error(")", TokenError),
                        },
                        Unmatch => {
                            self.previous();
                        }
                        _ => return Fail,
                    }
                } else {
                    self.previous();
                }
            }
            _ => {}
        }
        match self.unary_expression() {
            Match => Match,
            _ => Fail,
        }
    }

    /// Parser::pointer_type
    ///
    /// Parse a pointer_type, defined as
    ///
    /// Pointer_type -> Type_native Pointer
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn pointer_type(&mut self) -> ParserResult {
        debug_println!("-> pointer_type");
        match self.type_native() {
            Match => match self.pointer() {
                Match => Match,
                Unmatch => Match,
                Fail => Fail,
            },
            _ => Fail,
        }
    }

    /// Parser::pointer
    ///
    /// Parse a pointer, defined as
    ///
    /// Pointer -> * Pointer
    ///          | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn pointer(&mut self) -> ParserResult {
        debug_println!("-> pointer");
        match self.get_current() {
            Tk::Operator(Asterisk) => {
                self.advance();
                match self.pointer() {
                    Fail => return Fail,
                    Match => return Match,
                    Unmatch => return Unmatch,
                }
            }
            Tk::Identifier(_) => return Unmatch,
            Tk::Bracket(RBracket) => return Unmatch,
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::type_native
    ///
    /// Parse a type_native, defined as
    ///
    /// Type_native -> u8 | u16 | u32 | i8 | i16 | i32 | void
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn type_native(&mut self) -> ParserResult {
        debug_println!("-> type_native");
        if self.get_current().is_type() {
            self.advance();
            return Match;
        } else {
            return self.parser_error("type", TokenError);
        }
    }

    /// Parser::unary_expression
    ///
    /// Parse a unary_expression, defined as
    ///
    /// Unary_expression -> Postfix_expression
    ///                   | + Unary_expression
    ///                   | - Unary_expression
    ///                   | ! Unary_expression
    ///                   | & Unary_expression
    ///                   | * Unary_expression
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn unary_expression(&mut self) -> ParserResult {
        debug_println!("-> unary_expression");
        match self.get_current() {
            Tk::Operator(Plus)
            | Tk::Operator(Minus)
            | Tk::Operator(Complement)
            | Tk::Operator(AndOp)
            | Tk::Operator(Asterisk) => {
                self.advance();
                match self.unary_expression() {
                    Match => Match,
                    _ => Fail,
                }
            }
            _ => match self.postfix_expression() {
                Match => Match,
                _ => Fail,
            },
        }
    }

    /// Parser::postfix_expression
    ///
    /// Parse a postfix_expression, defined as
    ///
    /// Postfix_expression ->   Primary_expression  Postfix_operator
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn postfix_expression(&mut self) -> ParserResult {
        debug_println!("-> postfix_expression");
        match self.primary_expression() {
            Match => match self.postfix_operator() {
                Match => return Match,
                Unmatch => return Match,
                Fail => return Fail,
            },
            _ => return Fail,
        }
    }

    /// Parser::postfix_operator
    ///
    /// Parse a postfix_operator, defined as
    ///
    /// Postfix_operator -> [ Expression ] Postfix_operator
    ///                   | ( ) Postfix_operator
    ///                   | ( Expression_list ) Postfix_operator
    ///                   | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn postfix_operator(&mut self) -> ParserResult {
        debug_println!("-> postfix_operator");
        match self.get_current() {
            Tk::Bracket(LSquare) => {
                self.advance();
                match self.expression() {
                    Match => match self.get_current() {
                        Tk::Bracket(RSquare) => {
                            self.advance();
                            match self.postfix_operator() {
                                Fail => Fail,
                                Unmatch => Match,
                                Match => Match,
                            }
                        }
                        _ => return self.parser_error("]", TokenError),
                    },
                    _ => Fail,
                }
            }
            Tk::Bracket(LBracket) => {
                self.advance();
                match self.get_current() {
                    Tk::Bracket(RBracket) => {
                        self.advance();
                        match self.postfix_operator() {
                            Fail => return Fail,
                            Unmatch => return Match,
                            Match => return Match,
                        }
                    }
                    _ => {}
                }
                match self.expression_list() {
                    Match => match self.get_current() {
                        Tk::Bracket(RBracket) => {
                            self.advance();
                            match self.postfix_operator() {
                                Fail => return Fail,
                                Unmatch => return Match,
                                Match => return Match,
                            }
                        }
                        _ => return self.parser_error(")", TokenError),
                    },
                    _ => Fail,
                }
            }
            Tk::Bracket(RBracket)
            | Tk::Semicolon
            | Tk::Bracket(RSquare)
            | Tk::Operator(Comma)
            | Tk::Operator(AndOp)
            | Tk::Operator(OrOp)
            | Tk::Operator(XorOp)
            | Tk::Keyword(And)
            | Tk::Keyword(Or)
            | Tk::Operator(EqualCompare)
            | Tk::Operator(DiffCompare)
            | Tk::Operator(LTCompare)
            | Tk::Operator(GTCompare)
            | Tk::Operator(LECompare)
            | Tk::Operator(GECompare)
            | Tk::Operator(LShift)
            | Tk::Operator(RShift)
            | Tk::Operator(Asterisk)
            | Tk::Operator(Slash)
            | Tk::Operator(Module)
            | Tk::Operator(Assign)
            | Tk::Operator(Plus)
            | Tk::Operator(Minus) => return Unmatch,
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::primary_expression
    ///
    /// Parse a primary_expression, defined as
    ///
    /// Primary_expression ->   identifier
    ///                     |   number
    ///                     |   char
    ///                     |   ( Expression )
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn primary_expression(&mut self) -> ParserResult {
        debug_println!("-> primary_expression");
        match self.get_current() {
            Tk::Identifier(_) => {
                self.advance();
                return Match;
            }
            Tk::IntegerLiteral(_) => {
                self.advance();
                return Match;
            }
            Tk::Char(_) => {
                self.advance();
                return Match;
            }
            Tk::Bracket(LBracket) => {
                self.advance();
                match self.expression() {
                    Match => match self.get_current() {
                        Tk::Bracket(RBracket) => {
                            self.advance();
                            return Match;
                        }
                        _ => return self.parser_error(")", TokenError),
                    },
                    _ => return Fail,
                }
            }
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::expression_list
    ///
    /// Parse a expression_list, defined as
    ///
    /// Expression_list ->  Expression Expression_list_star
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_list(&mut self) -> ParserResult {
        debug_println!("-> expression_list");
        match self.expression() {
            Match => match self.expression_list_star() {
                Match => Match,
                Fail => Fail,
                Unmatch => Match,
            },
            _ => return Fail,
        }
    }

    /// Parser::expression_list_star
    ///
    /// Parse a expression_list_star, defined as
    ///
    /// Expression_list_star -> , Expression_list
    ///                       | ε
    ///
    /// @return [ParseResult]: return Match with the corresponding AST in case of success, Fail in
    /// case of error, Unmatch in case of non correspondant parse way, whenever it is possible
    fn expression_list_star(&mut self) -> ParserResult {
        debug_println!("-> expression_list_star");
        match self.get_current() {
            Tk::Operator(Comma) => {
                self.advance();
                match self.expression_list() {
                    Match => return Match,
                    _ => return Fail,
                }
            }
            Tk::Bracket(RBracket) => return Unmatch,
            _ => return self.parser_error("", TokenError),
        }
    }

    /// Parser::parser_error
    ///
    /// Generate an error from the parser
    ///
    /// @in expected [&str]: string to give some information about the error
    /// @in error [ParserErrorType]: type of error to handle
    /// @return [ParseResult]: Always Fail
    fn parser_error(&mut self, expected: &str, error: ParserErrorType) -> ParserResult {
        if self.skip_erorrs {
            return Fail;
        }
        self.errors_counter += 1;
        let line_number = self.token_list[self.current_position].line_number;
        let last_character = self.token_list[self.current_position].last_character;
        let first_character = self.token_list[self.current_position].first_character;
        let file_lines = self.read_lines(&self.file_name);

        eprint!(
            "\x1b[34m{}:{}:{}: \x1b[0m",
            self.file_name, line_number, first_character
        );

        match error {
            TokenError => {
                if expected.len() != 0 {
                    eprintln!(
                        "\x1b[91merror parser: \x1b[0mexpected `\x1b[34m{}\x1b[0m`, found `\x1b[34m{}\x1b[0m`",
                        expected,
                        self.get_current()
                    );
                } else {
                    eprintln!(
                        "\x1b[91merror parser: \x1b[0munexpected token `\x1b[34m{}\x1b[0m`",
                        self.get_current()
                    );
                }
            }
            _ => {}
        }
        if line_number as usize > file_lines.len() {
            return Fail;
        }

        eprint!(
            "{}\t| {}\n\t| ",
            line_number,
            file_lines[line_number as usize - 1]
        );

        for i in 0..last_character {
            if i < first_character - 1 {
                eprint!(" ");
            } else if i == first_character - 1 {
                eprint!("\x1b[91m^\x1b[0m");
            } else {
                eprint!("\x1b[91m~\x1b[0m");
            }
        }
        eprintln!("");

        return Fail;
    }

    fn read_lines(&self, filename: &str) -> Vec<String> {
        let mut result = Vec::new();

        for line in read_to_string(filename).unwrap().lines() {
            result.push(line.to_string())
        }

        result
    }
}
